---
title: Как декораторы могут упростить разработку веб-форм
meta_title: |
  Как Декораторы Могут Упростить Разработку Веб-Форм - Фул...
description: >
  Недавно, в рамках TC39, предложение по внедрению декораторов в ECMAScript
  достигло третьего пре-финального этапа. Немного позже Microsoft выпустила
  пятую...
date: 2023-10-23T22:29:30.473Z
image: >-
  ../../assets/images/kak-dekoratory-mogut-uprostitь-razrabotku-veb-form-Oct-24-2023.avif
categories:
  - Как закодить
author: Igor Gorlov
tags:
  - JavaScript
  - MobX
  - React
  - TypeScript
draft: false
keywords: ''
type: blog
slug: kak-dekoratory-mogut-uprostitь-razrabotku-veb-form
lastmod: 2024-03-20T21:26:47.293Z
---

Недавно, в рамках TC39, предложение по внедрению декораторов в ECMAScript достигло третьего пре-финального этапа. Немного позже Microsoft выпустила пятую версию TypeScript, где новая реализация декораторов начала работать "из коробки" без экспериментальных флагов. Babel также взял на себя инициативу и в своей документации стал рекомендовать использовать новую реализацию декораторов. Все это означает, что декораторы наконец-то начинают полноценно входить в жизнь разработчиков JavaScript.

Именно по этой теме я решил рассказать, как с помощью декораторов можно улучшить опыт разработчика при создании форм.

Следует отметить, что в этой статье я буду рассказывать об подходе, основанном на использовании библиотеки MobX. Поэтому, если вы не используете MobX в своих проектах, статья может быть не так полезной, как могла бы быть. Однако вы можете прочесть ее как возможный источник вдохновения по созданию веб-форм.

<!-- wp:rank-math/toc-block {"title":"Оглавление","headings":[{"key":"15396ecc-002b-478d-9e32-57904c058609","content":"Немного о предыстории","level":2,"link":"#немного-о-предыстории","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"def0d0c3-c76c-4817-b1b5-66872aa587f0","content":"Модель формы MobX","level":2,"link":"#модель-формы-mob-x","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"008accd1-bdb4-4160-8b16-6640a8ded88d","content":"Валидация формы","level":2,"link":"#валидация-формы","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"81b256e3-5511-47b1-8bbf-604c86ecfdeb","content":"Как выглядит функция-валидатор?","level":3,"link":"#как-выглядит-функция-валидатор","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"7ec8595f-b561-47fb-9840-342653ff8e35","content":"Условная валидация","level":3,"link":"#условная-валидация","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"1e7b0e9f-0034-4c54-9fed-b26d859a4ddd","content":"Когда происходит валидация?","level":3,"link":"#когда-происходит-валидация","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"d03162af-8cd3-4ae4-bf5d-586e46944ded","content":"Краткое резюме по валидации","level":3,"link":"#краткое-резюме-по-валидации","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"93d6b69f-f3ba-45c9-a1bb-b74c533bee76","content":"Отслеживание изменений формы","level":2,"link":"#отслеживание-изменений-формы","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"5764354e-7e62-42c8-9e91-873b7c6b5054","content":"Отслеживание сложных объектов","level":3,"link":"#отслеживание-сложных-объектов","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"8301b610-ad73-4def-82b2-084e73ccf2da","content":"Отслеживание вложенных схем","level":3,"link":"#отслеживание-вложенных-схем","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"0aff8b34-4404-4f5c-a51f-a3bc1c0be563","content":"Восстановление формы в исходное состояние","level":3,"link":"#восстановление-формы-в-исходное-состояние","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"d41ee38f-ea49-4983-9398-02ffad01c7cf","content":"Краткое заключение о слежении за изменениями","level":3,"link":"#краткое-заключение-о-слежении-за-изменениями","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"f8e597e0-d1fa-4cc5-9828-9de34224720d","content":"​Взаимодействие формы с сервером","level":2,"link":"#взаимодействие-формы-с-сервером","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"8581f8db-54ec-4520-8c7a-1bb1bdb27e53","content":"Инициализация","level":3,"link":"#инициализация","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"a9018503-6bf4-4fb6-9021-aa69f0b27512","content":"Презентация","level":3,"link":"#презентация","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"0c4d1ba5-fa18-4f02-a756-3bba23043993","content":"А как это использовать в React?","level":2,"link":"#а-как-это-использовать-в-react","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"c62cce68-7574-4328-ae5a-f16270590320","content":"Итак, означает ли это, что декораторы - это универсальное средство?","level":2,"link":"#итак-означает-ли-это-что-декораторы-это-универсальное-средство","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"3a478c7b-0bb3-4394-b7b9-6c344b1bcb99","content":"Конец","level":2,"link":"#конец","disable":false,"isUpdated":false,"isGeneratedLink":true}],"listStyle":"ul"} -->
<div class="wp-block-rank-math-toc-block" id="rank-math-toc"><h2>Оглавление</h2><nav><ul><li class=""><a href="#немного-о-предыстории">Немного о предыстории</a></li><li class=""><a href="#модель-формы-mob-x">Модель формы MobX</a></li><li class=""><a href="#валидация-формы">Валидация формы</a><ul><li class=""><a href="#как-выглядит-функция-валидатор">Как выглядит функция-валидатор?</a></li><li class=""><a href="#условная-валидация">Условная валидация</a></li><li class=""><a href="#когда-происходит-валидация">Когда происходит валидация?</a></li><li class=""><a href="#краткое-резюме-по-валидации">Краткое резюме по валидации</a></li></ul></li><li class=""><a href="#отслеживание-изменений-формы">Отслеживание изменений формы</a><ul><li class=""><a href="#отслеживание-сложных-объектов">Отслеживание сложных объектов</a></li><li class=""><a href="#отслеживание-вложенных-схем">Отслеживание вложенных схем</a></li><li class=""><a href="#восстановление-формы-в-исходное-состояние">Восстановление формы в исходное состояние</a></li><li class=""><a href="#краткое-заключение-о-слежении-за-изменениями">Краткое заключение о слежении за изменениями</a></li></ul></li><li class=""><a href="#взаимодействие-формы-с-сервером">​Взаимодействие формы с сервером</a><ul><li class=""><a href="#инициализация">Инициализация</a></li><li class=""><a href="#презентация">Презентация</a></li></ul></li><li class=""><a href="#а-как-это-использовать-в-react">А как это использовать в React?</a></li><li class=""><a href="#итак-означает-ли-это-что-декораторы-это-универсальное-средство">Итак, означает ли это, что декораторы - это универсальное средство?</a></li><li class=""><a href="#конец">Конец</a></li></ul></nav></div>
<!-- /wp:rank-math/toc-block -->

<h2 class="wp-block-heading" id="немного-о-предыстории">Немного о предыстории</h2>

В моем предыдущем проекте мне пришлось разрабатывать множество сложных форм. Очень часто они состояли из десятков полей.

Большинство полей требовало валидации. Конечно, простые правила валидации, такие как проверка на заполненность поля или проверка правильности адреса электронной почты, возникали довольно часто. Но иногда эти правила были невероятно сложными. Например, в зависимости от того, что выбирает пользователь в одном поле, правила валидации для другого поля могли меняться. И в некоторых случаях было необходимо отключать валидацию одного поля при определенных значениях другого поля. И, конечно, для каждого поля могло быть несколько правил валидации, каждое из которых должно было выдавать свое собственное сообщение об ошибке.

Но валидация была только частью необходимой функциональности. Также нужно было отслеживать изменения в форме. Грубо говоря, отключать кнопку отправки, пока пользователь не внесет какие-либо изменения. Но, опять же, на формах было десятки полей, поэтому написание блоков if для каждого поля не было лучшим решением.

Ситуацию усугубляло то, что некоторые поля могли представлять собой массивы и наборы данных. И если пользователь удалял несколько значений из такого поля, а затем вводил те же значения вручную, форма должна была понимать, что вернулась к исходному состоянию. Кроме того, формы должны были уметь сбрасывать текущее состояние формы к исходному. И, конечно же, они должны были уметь взаимодействовать с сервером.

Я рассматривал различные библиотеки, такие как React Hook Form или Formik, но эти варианты меня не устроили. В масштабе этих требований код, даже с использованием этих библиотек, оказался слишком громоздким и трудноподдерживаемым. Поэтому я начал разрабатывать свое собственное решение.

<h2 class="wp-block-heading" id="модель-формы-mob-x">Модель формы MobX</h2>

Важным шагом было разделение представления и логики. Мне нужно было найти способ описать логику формы в отдельной функции или объекте и минимизировать необходимость в повторении кода насколько это возможно.

В итоге я пришел к выводу, что удобно описывать логику формы в отдельном классе JavaScript. Далее в тексте я буду называть такой класс "схемой формы". Каждое свойство такого класса может представлять поле в форме или выполнять какой-либо вспомогательный функционал. С помощью декораторов можно присвоить необходимую логику для каждого свойства.

В самом простом представлении, такой объект является обычным MobX хранилищем. Например, в следующем фрагменте кода показан самый простой пример схемы формы, состоящей из двух полей: "Имя" и "Фамилия". Пока без какой-либо логики.

```javascript
import { makeObservable, observable } from 'mobx';

export class BasicFormStore {
	name = '';

	surname = '';

	constructor() {
		makeObservable(this, {
			name: observable,
			surname: observable,
		});
	}
}
```

<h2 class="wp-block-heading" id="валидация-формы">Валидация формы</h2>

Что такое валидация поля? Это одно или несколько правил для проверки значения поля. В нашем случае "поле" - это свойство класса. Это означает, что с помощью декоратора @validate можно назначить несколько правил валидации для соответствующего свойства.

```javascript
import { FormSchema, validate } from '@yoskutik/mobx-form-schema';
import { makeObservable, observable } from 'mobx';
import { email, required } from 'path/to/validators';

export class LoginSchema extends FormSchema {
	@validate(required(), email())
	email = '';

	constructor() {
		super();
		makeObservable(this, {
			email: observable,
		});
	}
}

const schema = LoginSchema.create();
console.log(schema.isValid, schema.errors);
// false, { email: 'The field is required' }

schema.email = 'invalid.email';
console.log(schema.isValid, schema.errors);
// false, { email: 'Invalid email format' }

schema.email = 'valid@email.com';
console.log(schema.isValid, schema.errors);
// true, {}
```

Вы просто передаете несколько функций-валидаторов декоратору, и схема самостоятельно выполняет валидацию значения поля. Если есть несколько валидаторов, схема применяет их последовательно. И только если все правила успешно прошли, схема сообщает, что поле действительно.

И снова мы видим разделение кода. Логика формы хранится отдельно от объявления валидаторов. Конечно, это делается намеренно. Таким образом, формируется подход к написанию атомарных функций валидации. И благодаря этому общие правила могут легко повторно использоваться.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="как-выглядит-функция-валидатор">Как выглядит функция-валидатор?</h3>

Функция-валидатор для схемы представляет собой просто функцию, которая возвращает либо строку, либо булево значение.

```javascript
export const required = () => (value?: string) => {
  if (value?.trim()) return false;
  return 'This field is required';
};

export const email = () => (value: string) => {
  if (/\S+@\S+\.\S+/.test(value)) return false;
  return 'Invalid email format';
};

export const minLength = (min: number) => (value: string) => {
  if (value.length >= min) return false;
  return `Should be at least ${min} characters.`;
};

```

Если функция возвращает false, валидация считается успешной. И если строка или true - нет. Более того, строка, переданная в валидатор, становится сообщением об ошибке для поля.

В качестве первого входного параметра функция получает текущее значение свойства. И в случае сложной валидации каждая функция-валидатор получает весь объект-схему со всеми свойствами в качестве второго параметра.

Поле "подтверждение пароля" должно иметь точно такое же значение, как и поле "пароль". Поле ввода даты "с" должно содержать дату, предшествующую дате в поле "по". Это базовые примеры тех случаев, когда нам нужно использовать всю схему для валидации.

Приведенный ниже пример показывает форму регистрации с примером проверки поля подтверждения пароля.

```javascript
import { FormSchema, validate } from '@yoskutik/mobx-form-schema';
import { makeObservable, observable } from 'mobx';
import { email, minLength, required } from 'path/to/validators';

const confirmPassword = () => (
  // Let’s use the second argument in order to understand whether
  //  the “confirmPassword” is the same as “password”
  (confirmPasswordValue: string, schema: SignUpSchema) => {
    if (confirmPasswordValue === schema.password) return false;
    return 'Passwords mismatched';
  }
);

export class SignUpSchema extends FormSchema {
  // Email address field
  @validate(required(), email())
  email = '';

  // Password field
  @validate(required(), minLength(8))
  password = '';

  // Password confirmation field
  @validate(required(), confirmPassword())
  confirmPassword = '';

  constructor() {
    super();
    makeObservable(this, {
      email: observable,
      password: observable,
      confirmPassword: observable,
    });
  }
}

```

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="условная-валидация">Условная валидация</h3>

Как я уже отмечал ранее, иногда могут возникать ситуации, когда валидацию нужно отключить. Поля могут быть необязательными или скрытыми по каким-то причинам, и в некоторых случаях валидация должна быть отключена в зависимости от значений в других полях.

Поскольку декоратор @validate уже используется для объявления обычной валидации, мы не можем использовать его. Но мы можем создать его модификатор: @validate.if. Такой модификатор будет работать практически так же, как и оригинальный, с единственным исключением: в дополнение к массиву валидаторов нужно передать предикатную функцию, которая говорит, нужна ли валидация в данный момент. Если предикат говорит, что валидация не требуется, свойство считается действительным.

Приведенный ниже пример показывает схему трех полей:

<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li>Необязательное поле для ввода адреса электронной почты.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Флажок, в котором пользователь говорит, что у него есть домашний питомец.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Поле для ввода имени питомца. Если флажок активен, необходимо выполнять валидацию на предмет полноты поля.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

```javascript
import { FormSchema, validate } from '@yoskutik/mobx-form-schema';
import { makeObservable, observable, runInAction } from 'mobx';
import { email, required } from 'path/to/validators';

const shouldValidatePetName = (_name: string, schema: ConditionalSchema) => (
  schema.doesHavePet
);

export class ConditionalSchema extends FormSchema {
  // or it can be @validate.if(email => !!email, [email()])
  @validate.if(Boolean, [email()])
  email = '';

  doesHavePet = false;

  @validate.if(shouldValidatePetName, [required()])
  petName = '';

  constructor() {
    super();
    makeObservable(this, {
      email: observable,
      doesHavePet: observable,
      petName: observable,
    });
  }
}

const schema = ConditionalSchema.create();
console.log(schema.isValid, schema.errors); // true, {}

runInAction(() => schema.doesHavePet = true);
console.log(schema.isValid, schema.errors);
// false, { petName: 'The value is required.' }

runInAction(() => schema.email = 'invalid.email');
console.log(schema.isValid, schema.errors);
// false, {
//   petName: 'The value is required.',
//   email: 'Invalid email format.',
// }

```

Это довольно простой пример валидации. Вы можете посмотреть более сложные примеры валидации, включая условную валидацию и правила, которые используют всю схему, на сайте документации.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="когда-происходит-валидация">Когда происходит валидация?</h3>

По умолчанию схема вычисляет валидацию в функции autorun из библиотеки MobX. Благодаря этому валидация свойства автоматически пересчитывается при его изменении. Но из-за этого, если другие свойства схемы участвовали в валидации, то при их изменении также будет пересчитана валидация.

Та же самая логика применяется к функции условной валидации. Если изменено нужное свойство или свойство, участвующее в условии, предикатная функция будет вызвана снова.

Вам не нужно беспокоиться о лишних пересчетах. Благодаря оптимизациям MobX и MobX Form Schema их не происходит. Тем не менее, возможно отключить автоматическую валидацию и начать валидировать данные вручную. Вы можете посмотреть примеры ручной валидации по ссылке.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="краткое-резюме-по-валидации">Краткое резюме по валидации</h3>

Эти преимущества могут показаться субъективными, но мне действительно понравился такой подход в разработке кода. Он хорошо читаем и легко поддерживается. Он достаточно гибок и даже в сложных случаях не заставляет вас писать сложную логику.

Недостатком может показаться необходимость писать валидаторы с нуля. Даже самые базовые. В то время как другие библиотеки поставляют их готовыми. Но у меня есть замечания по этому поводу:

Даже базовые правила могут различаться для разных проектов. Например, валидация номера телефона или адреса электронной почты может различаться в разных странах.

Приложение может поддерживать несколько языков. И даже в пределах одного языка могут возникнуть ситуации, когда одно и то же правило в разных полях должно выдавать разные сообщения об ошибке.

Обе эти точки приводят к необходимости предоставления функциональности для переопределения или настройки базовых валидаторов. Но, как вы сами видели, базовые валидаторы могут состоять всего из 3 строк кода. И для меня лучше написать 3 строки кода с нуля, чем писать их для настройки готовой функциональности "из коробки".

Что также замечательно, MobX Form Schema работает с декораторами как новой, так и старой реализации. Однако новая реализация обладает хорошей поддержкой типов, поэтому я не могу передать валидатор для числа в свойство строкового типа.

```javascript
const rule = () => (value: number) => {
  if (value > 0) return false;
  return 'The value must be greater than 0';
};

export class SignUpSchema extends FormSchema {
  // a typing error here, since `rule` must work with number properties
  @validate(rule())
  email = '';
}

```

​

<h2 class="wp-block-heading" id="отслеживание-изменений-формы">Отслеживание изменений формы</h2>

Теперь давайте перейдем от валидации к отслеживанию изменений формы. Не сложно понять, что форма была изменена. Сначала вам нужно сохранить начальное состояние формы. Во-вторых, в нужный момент достаточно использовать такой кусок кода:

```javascript
const isChanged = currentValue1 !== initialValue1
  || currentValue2 !== initialValue2
  || ...;

```

Это эффективный и простой способ, но он подходит только для простых форм. Чем больше полей в форме, тем длиннее будет это условие и тем сложнее будет поддерживать такой код.

Но это не единственная проблема. Помимо простых текстовых полей в форме могут быть более сложные поля. Например, на большинстве сайтов, связанных с карьерой, есть поле для указания навыков. И значение такого поля фактически должно быть либо массивом, либо множеством. И простое сравнение ссылок здесь не поможет понять, изменилось ли состояние формы.

Существует другой подход: глубокое сравнение.

```javascript
import isEqual from 'lodash/isEqual';
const isChanged = isEqual(currentState, initialState);
```

Этот подход решает описанные выше проблемы. Однако затем возникают проблемы с лишними вычислениями. Идеально, чтобы форма говорила, изменилась она или нет после любого взаимодействия пользователя. Но вызывать глубокое сравнение при каждом изменении может быть слишком ресурсозатратным.

MobX позволяет обойти обе эти проблемы. В схеме формы, при изменении определенного поля, происходит только сравнение, которое проверяет, изменилось ли именно это поле.

И чтобы активировать отслеживание изменений формы, достаточно использовать декоратор: @watch.

```javascript
export class UserSchema extends FormSchema {
	@watch name = 'Initial name';

	@watch surname = 'Initial surname';
}

const schema = UserSchema.create();

console.log(schema.isChanged); // false

schema.name = 'New Name';
console.log(
	schema.isChanged, // true
	schema.getInitial('name'), // 'Initial name'
);

schema.name = 'Initial name';
console.log(schema.isChanged); // false
```

В этой форме флаг isChanged всегда будет равен false, если имя равно "Initial name", а фамилия равна "Initial surname". Даже если свойство изменит свое значение на другое, а затем вернется к исходному состоянию.

Декоратор @watch использует сравнение по ссылке и сообщает схеме, изменилось ли значение свойства по сравнению с его исходным состоянием.

Вы могли заметить, что в приведенном выше примере я не вызывал функцию makeObservable. Это потому, что по умолчанию @watch применяет observable.ref к свойствам. Это делается по логическим причинам - если вам нужно только сравнение по ссылке, вряд ли вам потребуется глубокое наблюдение через observable. Тем не менее, вы можете добавить его или любые другие модификации observable сами без проблем.

Более важно, сама схема не помнит свое исходное состояние. Но если вы примените @watch, схема сохранит исходное состояние только для нужных полей. Таким образом, нет лишних расходов памяти.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="отслеживание-сложных-объектов">Отслеживание сложных объектов</h3>

Благодаря сравнению по ссылке, @watch в основном нужен для наблюдения за примитивными значениями. Немного сложнее, когда речь идет о наблюдении за объектами. Например, при проверке, изменился ли массив, нам нужно проверить количество элементов в начальном и текущем состояниях, а также убедиться, что элементы совпадают на каждой из позиций.

Но декораторы-модификаторы приходят нам на помощь снова. С их помощью мы можем создать такие модификаторы, в которых вместо сравнения по ссылке будет использоваться некий другой тип сравнения. Например, если вы хотите использовать массив значений, используйте @watch.array, и если есть множество, используйте @watch.set. По умолчанию эти декораторы будут применять к свойствам схемы observable.shallow.

```javascript
import { FormSchema, watch } from '@yoskutik/mobx-form-schema';
import { runInAction } from 'mobx';

export class ArraySchema extends FormSchema {
	@watch.array skillsArray = ['HTML', 'CSS', 'JavaScript'];

	@watch.set skillsSet = new Set(['HTML', 'CSS', 'JavaScript']);
}

const schema = ArraySchema.create();

runInAction(() => (schema.skillsArray = ['HTML']));
console.log(schema.isChanged, schema.changedProperties);
// true, Set(['skillsArray'])

runInAction(() => schema.skillsArray.push('CSS', 'JavaScript'));
console.log(schema.isChanged, schema.changedProperties);
// false, Set()

runInAction(() => schema.skillsSet.delete('CSS'));
console.log(schema.isChanged, schema.changedProperties);
// true, Set(['skillsSet'])

runInAction(() => schema.skillsSet.add('CSS'));
console.log(schema.isChanged, schema.changedProperties);
// false, Set()
```

Повторюсь, новые декораторы лучше работают с типизацией. Вы не можете применить @watch.array к свойству, не являющемуся массивом, или @watch.set к свойству, не являющемуся множеством.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="отслеживание-вложенных-схем">Отслеживание вложенных схем</h3>

Схемы могут быть вложенными. Самая простая причина для этого - логическое разделение данных. Например, в форме информации о пользователе информация о его контактах может быть отдельной схемой, вложенной в главную схему.

```javascript
import { FormSchema, watch } from '@yoskutik/mobx-form-schema';
import { runInAction } from 'mobx';

export class ContactsSchema extends FormSchema {
	@watch tel = 'default tel value';

	@watch email = 'default email value';
}

export class InfoSchema extends FormSchema {
	@watch name = '';

	@watch surname = '';

	@watch.schema contacts = ContactsSchema.create();
}

const schema = InfoSchema.create();

runInAction(() => (schema.contacts.tel = 'new value'));
console.log(schema.isChanged, schema.changedProperties);
// true, Set(['contacts'])

runInAction(() => (schema.contacts.tel = 'default tel value'));
console.log(schema.isChanged, schema.changedProperties);
// false, Set()

runInAction(() => (schema.contacts = ContactsSchema.create()));
console.log(schema.isChanged, schema.changedProperties);
// false, Set()
```

И, конечно, такая вложенная отдельная схема может использоваться в будущем без родительской схемы, если такая ситуация потребуется.

Кроме того, вы можете использовать модификатор @watch.schemasArray, если вам нужно использовать массив вложенных схем. Такой массив, например, может быть массивом блоков информации об опыте работы в форме резюме.

В случае, если у вас есть нестандартная структура данных, требующая нестандартной функции сравнения, вы можете создать собственную модификацию декоратора @watch с помощью метода watch.create. Но чтобы не раздувать статью, я просто скромно оставлю ссылку на документацию, если вас интересует просмотр примеров использования @watch.schemasArray и watch.create.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="восстановление-формы-в-исходное-состояние">Восстановление формы в исходное состояние</h3>

В некоторых случаях функция восстановления формы может быть полезной. Особенно в формах редактирования с предзаполненными данными с сервера. И поскольку мы уже храним исходное состояние формы, нам совсем не сложно восстановить форму в исходное состояние.

```javascript
import { FormSchema, watch } from '@yoskutik/mobx-form-schema';
import { runInAction } from 'mobx';

export class BasicSchema extends FormSchema {
	@watch name = 'Joe';

	@watch surname = 'Dough';
}

const schema = BasicSchema.create();

runInAction(() => {
	schema.name = 'new name';
	schema.surname = 'new surname';
});

console.log(schema.name, schema.surname); // 'new name', 'new surname'
schema.reset();
console.log(schema.name, schema.surname); // 'Joe', 'Dough'
```

И, конечно, массивы, множества, вложенные схемы и даже ваши собственные сущности (если вы описали их правильно) — все они будут корректно восстановлены.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="краткое-заключение-о-слежении-за-изменениями">Краткое заключение о слежении за изменениями</h3>

Я кратко отмечу, что, как и с валидацией, изменения отслеживаются автоматически. Но, конечно, также доступна возможность вручную проверять изменения.

Итак, с помощью всего лишь пары декораторов и методов полностью автоматизировано отслеживание изменений формы. Независимо от сложности схемы или количества вложенных схем в ней, вы всегда сможете понять, изменилась ли ваша форма. И вы всегда сможете восстановить ее в исходное состояние.

Вы даже можете создать схему формы для настроек IDE. Обычно в таких формах много вкладок, внутри которых есть вложенные вкладки. И вы легко можете отслеживать изменения и сбрасывать форму полностью, только на определенной вкладке или только во вложенной вкладке.

При этом эти наблюдения достаточно дешевы. Когда поле меняется, проверяется только это поле.

И, конечно, то, что @watch и его модификации способны сами применять модификации MobX к свойствам, позволяет сократить ваш код еще больше.

<h2 class="wp-block-heading" id="взаимодействие-формы-с-сервером">​Взаимодействие формы с сервером</h2>

Иногда данные, полученные с сервера, требуют некоторой предварительной обработки перед использованием. Например, сервер не может отправить сущность Set или Date, но вам может быть удобнее использовать данные в этом формате.

Может быть и обратная ситуация, когда сервер требует данные в другом формате, чем тот, в котором они хранятся в схеме.

И обычно разработчики, которые испытывают такую необходимость, модифицируют данные после получения их, перед использованием или перед отправкой. Но с помощью схемы формы такие изменения можно описать непосредственно в схеме.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="инициализация">Инициализация</h3>

В предыдущих примерах вы видели, что для создания схемы необходимо вызвать статический метод create. Этот метод может принимать объект в качестве аргумента, на основе которого схема может быть заполнена данными.

```javascript
import { FormSchema } from '@yoskutik/mobx-form-schema';

export class BasicSchema extends FormSchema {
	name = '';

	surname = '';
}

const schema1 = BasicSchema.create();
console.log(schema1.name, schema1.surname); // '', ''

const schema2 = BasicSchema.create({
	name: 'Joe',
	surname: 'Dough',
});
console.log(schema2.name, schema2.surname); // 'Joe', 'Dough'
```

Вы также можете описать, как данные, полученные в этом методе, должны быть предварительно обработаны перед тем, как схема начнет их использовать. Для этого можно использовать декоратор @factory.

```javascript
import { factory, FormSchema } from '@yoskutik/mobx-form-schema';

const createDate = (data: string) => new Date(data);

export class BasicSchema extends FormSchema {
  @factory.set
  set = new Set<number>();

  @factory(createDate)
  date = new Date();
}

const schema = BasicSchema.create({
  set: [0, 1, 2],
  date: '2023-01-01T00:00:00.000Z',
});
console.log(schema.set instanceof Set, schema.date instanceof Date);
// true, true

```

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="презентация">Презентация</h3>

Поскольку каждая схема содержит вспомогательные данные и методы, для вас может быть полезно получить объект, содержащий исключительно полезные данные из схемы. Для этого вы можете использовать геттер presentation схемы, который по умолчанию создает копию схемы без вспомогательных методов и свойств.

```javascript
import { FormSchema } from '@yoskutik/mobx-form-schema';

export class BasicSchema extends FormSchema {
	name = 'Joe';

	surname = 'Dough';
}

const schema = BasicSchema.create();
console.log(schema.presentation);
// {
//   name: 'Joe',
//   surname: 'Dough',
// }
```

Вы также можете использовать декоратор @present для изменения содержимого объекта презентации. И даже вы можете убрать некоторые из его свойств. Например, вам, вероятно, не захочется отправлять значение поля подтверждения пароля на сервер. Для этого вы можете использовать модификатор @present.hidden.

```javascript
import { FormSchema, present } from '@yoskutik/mobx-form-schema';

const presentUsername = (username: string) => `@${username}`;

export class BasicSchema extends FormSchema {
  @present(presentUsername)
  username = 'joe-man';

  name = 'Joe';

  @present.hidden
  someUtilityProperty = 'utility data';
}

const schema = BasicSchema.create();
console.log(schema.presentation);
// {
//   name: 'Joe',
//   username: '@joe-man',
// }

```

И впоследствии вы можете использовать этот объект презентации при отправке данных на сервер.

<h2 class="wp-block-heading" id="а-как-это-использовать-в-react">А как это использовать в React?</h2>

Я создал MobX Form Schema как пакет с минимальным набором зависимостей. Поэтому необязательно использовать React. Единственное, что вам нужно - это MobX, который должен быть в проекте.

Но тем не менее, я понимаю, что в большинстве случаев MobX используется с React, поэтому я подготовил пример использования моей библиотеки в приложении React. Но чтобы не раздувать статью, я просто предоставлю вам ссылки на нее: веб-документация, CodeSandbox.io, StackBlitz.com.

И просто, чтобы вас заинтересовать, я кратко покажу, как может выглядеть компонент для отображения формы с именем питомца из раздела "Условная валидация".

```javascript
export const ConditionalExample = observer(() => {
	const schema = useMemo(() => ConditionalSchema.create(), []);

	return (
		<form>
			{/* Since error output is standardized, TextField is able to display them itself */}
			<TextField schema={schema} field="email" type="email" label="E-mail" />

			<CheckboxField schema={schema} field="doesHavePet" label="I have a pet" />

			{schema.doesHavePet && (
				<TextField schema={schema} label="Pet's name" field="petName" required />
			)}

			<button type="submit">Submit</button>
		</form>
	);
});
```

<h2 class="wp-block-heading" id="итак-означает-ли-это-что-декораторы-это-универсальное-средство">Итак, означает ли это, что декораторы - это универсальное средство?</h2>

Пытаюсь ли я утверждать в своей статье, что этот подход к разработке форм - единственно правильный? Нет, конечно, в разработке нет универсальных решений. Однако мне кажется, что этот подход действительно упрощает процесс разработки. И, что важно, он почти не влияет на размер вашего бандла - за исключением самого MobX, вся функциональность, которую я описал, хранится в пакете менее чем 4 КБ. И учитывая, что вам придется писать меньше кода, вы только выиграете в размере бандла.

Более того, этот подход работает хорошо как с небольшими, так и с крупными формами.

Однако, да, вам понадобится MobX. По крайней мере, в моей реализации. Если кто-то сделает что-то подобное для других менеджеров состояния, мне будет интересно это увидеть.

<h2 class="wp-block-heading" id="конец">Конец</h2>

В статье я показал большую часть, но не всю функциональность схемы формы. Я не показал, как работает валидация и отслеживание изменений в ручном режиме; я не показал все модификаторы декораторов. И вообще, если вас интересует этот подход к разработке форм, я рекомендую посетить <a href="https://yoskutik.github.io/mobx-form-schema/#/">сайт с документацией</a>. Там есть много полезных материалов, включая полезные сценарии использования схемы формы. Я жду ваших отзывов в комментариях. Как вам этот подход в целом?

Ссылка на <a href="https://www.npmjs.com/package/@yoskutik/mobx-form-schema">пакет npm</a>.

Пока.
