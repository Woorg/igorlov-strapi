---
title: >-
  Модель, представление, контроллер в Rails: Глубокое погружение в архитектуру
  MVC
meta_title: >-
  Модель, представление, контроллер в Rails: Глубокое погружение в архитектуру
  MVC | Игорь Горлов - Фронтeндер
description: >-
  Для любого начинающего разработчика Ruby on Rails понимание архитектуры
  ModelViewController (MVC) сродни освоению азбуки вебразработки. Это
  фундаментальная
date: 2024-01-18T00:00:00.000Z
categories:
  - Учебник
author: Игорь Горлов
type: blog
draft: false
slug: model-predstavlenye-kontroller-v-rails-hlubokoe-pohruzhenye-v-arkhytekturu-mvc
tags:
  - Ruby
  - Rails
image: >-
  ../../assets/images/model-predstavlenye-kontroller-v-rails-hlubokoe-pohruzhenye-v-arkhytekturu-mvc-Jan-18-2024.avif
lastmod: 2024-03-20T21:26:46.949Z
---

Для любого начинающего разработчика Ruby on Rails понимание архитектуры Model-View-Controller (MVC) сродни освоению азбуки веб-разработки. Это фундаментальная основа, на которой строятся ваши приложения, обеспечивающая структурированную, модульную и удобную в обслуживании кодовую базу. Эта статья посвящена тонкостям архитектуры Rails MVC, и вы получите знания и практические примеры, чтобы уверенно двигаться по пути веб-разработки.

## [](#the-pillars-of-the-mvc-architecture-model-view-controller)Столпы архитектуры MVC: Модель, Представление, Контроллер

Представьте, что ваше приложение - это фильм.  
Модель **Model** представляет собой команду фильма, работающую на заднем плане всего производства, чтобы все происходило. **View** - это сцена и декорации - все то, что вы можете видеть и с чем взаимодействовать. **Контроллер** выступает в роли режиссера фильма, диктуя, что должна делать каждая часть или компонент на съемочной площадке. Каждый компонент играет отдельную роль, беспрепятственно взаимодействуя друг с другом, чтобы создать захватывающий опыт для ваших пользователей.

### [](#the-model)The Model

Модель - это класс Ruby, который используется для представления данных. Кроме того, модели могут взаимодействовать с базой данных приложения с помощью функции Rails под названием Active Record.  
Чтобы определить модель, мы воспользуемся генератором моделей:
Слой моделей - это центральный компонент любого приложения Rails; он обрабатывает данные, на основе которых работают ваши веб-страницы, и содержит бизнес-логику, определяющую, как данные создаются, читаются, обновляются и удаляются (операции CRUD). Вы можете представить себе слой Model как команду за кулисами, которая следит за тем, чтобы актеры были правильно одеты и подготовлены к своим ролям.

#### [](#data-representation)Представление данных

Модели представляют реальные сущности, такие как пользователи, продукты или заказы. Они определяют атрибуты, отношения и проверки для каждой сущности. Например, модель `User` может содержать такие атрибуты, как `имя`, `email` и `password`, с проверками, обеспечивающими уникальность электронной почты и надежность пароля.

#### [](#database-interactions)Взаимодействие с базой данных

Модели выступают в качестве посредников между вашим приложением и базой данных. Они предоставляют методы для получения, манипулирования и сохранения данных. Представьте себе модель `Product`, извлекающую информацию из таблицы `products` или обновляющую ее цену в базе данных.

#### [](#business-logic)Бизнес-логика

Модели инкапсулируют основную логику вашего приложения. Они определяют правила и вычисления, специфичные для вашего домена. Например, модель `Cart` может рассчитывать общую стоимость товаров на основе их количества и цены.

Чтобы определить модель, мы воспользуемся генератором моделей:

`bin/rails generate model Product name:string price:number`.

В примере выше мы пытаемся сгенерировать модель для товаров на странице электронной коммерции. Базе данных сообщается, что каждый продукт будет иметь атрибуты name и string.

### [](#the-view)The View

Слой View берет данные, предоставленные моделью, и преобразует их в визуальное представление, с которым взаимодействуют пользователи. Он генерирует HTML-контент, стили CSS и код JavaScript, которые рисуют картину вашего приложения на экране пользователя. Считайте, что это преобразование исходных данных в визуальный формат.

#### [](#templates)Шаблоны

Представления обычно пишутся в шаблонах ERB (Embedded Ruby), что позволяет динамически генерировать содержимое на основе данных, полученных из модели. Представьте себе шаблон `products/index.html.erb`, который итеративно просматривает список товаров и выводит их названия, цены и изображения.

#### [](#helpers)Helpers

Помощники представлений содержат фрагменты кода многократного использования для таких распространенных задач, как форматирование дат, генерация форм или вывод сообщений об ошибках. Они помогают поддерживать чистоту и удобство работы с представлениями.

#### [](#layout-and-../../assets)Макет и активы

Представления могут наследуют шаблоны макетов, которые определяют общую структуру страницы, включая верхние и нижние колонтитулы, а также боковые панели. Кроме того, отдельные файлы CSS и JavaScript обрабатывают стилистику и интерактивность, соответственно.

**Пример кода:**

```ruby
<h1>Продукты</h1>
<% @products.each do |product| %>
  <div class="product">
    <h2><%= product.name %></h2>
    <%= product.description %>
    Цена: $<%= product.price %>
    <%= link_to "Добавить в корзину", add_to_cart_path(product), class: "btn btn-primary" %>
  </div>
<% end %>
```

### [](#the-controller)Контроллер

Контроллер является связующим звеном между моделью и представлением. Он получает запросы пользователей, взаимодействует с моделью для получения данных или манипулирования ими и подготавливает данные для представления в представлении. Подумайте о нем как о дирижере, который интерпретирует действия пользователя и направляет актеров и команду для предоставления соответствующего ответа.

#### [](#actions)Actions

Контроллеры определяют `методы`, называемые действиями, которые обрабатывают определенные запросы пользователей. Например, контроллер `ProductsController` может содержать действие `index` для отображения всех товаров или действие `show` для отображения конкретного товара.

#### [](#routing)Routing

В Ruby on Rails под маршрутизацией понимается процесс определения того, как входящий HTTP-запрос должен быть обработан приложением. Система маршрутизации в Rails сопоставляет URL с действиями контроллера, помогая организовать и структурировать ваше веб-приложение. Маршруты определяются в файле `config/routes.rb`.

Вот пример контроллера ProductsController в Rails:

```ruby
class ProductsController < ApplicationController
  def index
    @products = Product.all
  end

  def show
    @product = Product.find(params[:id])
  end

  def create
    @product = Product.new(product_params)
    if @product.save
      redirect_to products_path, notice: 'Product created successfully'
    else
      render :new, status: :unprocessable_entity
    end
  end

  private

  def product_params
    params.require(:product).permit(:name, :price)
  end
end
```

Этот контроллер определяет действия для вывода списка товаров `index`, показа конкретного товара `show` и создания нового товара `create`. Он взаимодействует с моделью `Product`, получая данные и манипулируя ими, и указывает соответствующим представлениям, как отображать ответ.

## [](#the-rails-mvc-architecture-working-together)Архитектура Rails MVC, работающая вместе

Архитектура MVC способствует развитию симбиотических отношений между этими тремя компонентами. Пользователь, запрашивающий список товаров, запускает следующий поток:

- Контроллер получает запрос и определяет соответствующее действие (например, `index`).
- Контроллер взаимодействует с моделью Product, чтобы получить список всех продуктов.
- Контроллер передает полученные продукты `@products` в представление `products/index.html.erb`.
- Представление просматривает коллекцию @products и генерирует HTML-контент, отображающий названия и цены товаров.
- Сгенерированный HTML-контент отправляется обратно в браузер пользователя, отображая список товаров на экране.

## [](#benefits-of-the-mvc-architecture)Преимущества архитектуры MVC

- Ясность и ремонтопригодность: Разделение задач на отдельные уровни повышает читаемость и удобство сопровождения кода. Разработчики могут сосредоточиться на конкретных аспектах, не увязая в несвязном коде.
- Возможность повторного использования: Модели можно использовать повторно.
