---
title: Как найти первую и последнюю позицию элемента в отсортированном массиве
meta_title: >-
  Как найти первую и последнюю позицию элемента в отсортированном массиве - Фул
  Фронт Дев
description: >-
  ## Проблема


  В этой статье я расскажу о проблеме [Найти первую и последнюю позицию элемента
  в отсортированном массиве] (https://leetcode.com/problems/findfirs
date: 2023-12-07T23:15:38.548Z
image: >-
  ../../assets/images/kak-naity-pervuiu-y-posledniuiu-pozytsyiu-lementa-v-otsortyrovannom-massyve-Dec-08-2023.avif
categories:
  - Как закодить
author: Igor Gorlov
tags:
  - Python
draft: false
translated: ''
translatedPosition: ''
type: blog
slug: kak-naity-pervuiu-y-posledniuiu-pozytsyiu-lementa-v-otsortyrovannom-massyve
lastmod: 2024-03-20T21:26:47.494Z
---

## Проблема

В этой статье я расскажу о проблеме [Найти первую и последнюю позицию элемента в отсортированном массиве] (https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/).

Leetcode описывает проблему следующим образом:

> Учитывая массив целых чисел `nums`, отсортированных в неубывающем порядке, найдите начальную и конечную позицию заданного значения `target`.
>
> Если `target` не найдено в массиве, верните `[-1, -1]`.
>
> Вы должны написать алгоритм со сложностью времени выполнения `O(log n)`.

Пример:

> Вход: nums = \[5,7,7,8,8,10\], цель = 8
>
> Выход: \[3,4\]

Leetcode оценивает эту задачу как среднюю. Я думаю, что это подходящая оценка. Решение выполнимо, но требует некоторого понимания алгоритма.

### [](https://dev.to/scc33/how-to-find-first-and-last-position-of-element-in-sorted-array-d7f#naive-approach-and-its-limitations)Наивный подход и его ограничения

Наивный подход к решению этой задачи заключается в линейном сканировании массива для поиска первого и последнего вхождения целевого значения. Для этого нужно один раз пройтись по массиву, чтобы найти первое вхождение целевого значения и отметить этот индекс как начальную позицию, а затем еще раз пройтись по массиву, чтобы найти последнее вхождение и отметить его как конечную позицию.

Хотя этот подход работает, он требует `O(n)` времени для решения, что не удовлетворяет ограничению на `O(log n)` сложность во время выполнения. Поэтому он становится неэффективным при работе с большими наборами данных.

## [](https://dev.to/scc33/how-to-find-first-and-last-position-of-element-in-sorted-array-d7f#the-solution)Решение

Чтобы достичь сложности выполнения `O(log n)`, мы можем использовать [бинарный поиск](https://en.wikipedia.org/wiki/Binary_search_algorithm). Бинарный поиск возможен потому, что массив уже отсортирован. В этом оптимизированном подходе мы выполним два бинарных поиска:

1. **Поиск крайней левой позиции** : Первый бинарный поиск найдет крайнее левое или первое вхождение целевого значения.
2. **Поиск крайнего правого положения** : Второй двоичный поиск найдет крайнее правое или последнее вхождение целевого значения.

Вот как будет работать каждый двоичный поиск:

1. **Самая левая позиция** : Инициализируем `left` в 0 и `right` в `n - 1` (где `n` - длина массива). В цикле while вычислите средний индекс как `(left + right) // 2`. Если `target > nums[mid]`, установите `left = mid + 1`. В противном случае установите `right = mid - 1`. После цикла проверьте, является ли `nums[left]` целью для подтверждения.
2. **Крайняя правая позиция** : Инициализируйте `left` в 0 и `right` в `n - 1` снова. На этот раз, если `target >= nums[mid]`, установите `left = mid + 1`. В противном случае установите `right = mid - 1`. После цикла проверьте, является ли `nums[right]` целью для подтверждения.
3. Наконец, верните \[-1, -1\], если местоположение левой и правой позиции пересекаются.

Обратите внимание, что ключевое различие между левым и правым поиском заключается в том, что для правого поиска используется проверка на большее или равное.

```py
class Solution(object):
    def searchRange(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) / 2
            if target > nums[mid]:
                left = mid + 1
            else:
                right = mid - 1
        левый_к_возврату = левый

        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) / 2
            if target >= nums[mid]:
                left = mid + 1
            else:
                right = mid - 1

        если left_to_return <= right:
            return (left_to_return, right)
        else:
            return [-1, -1]
```

Вход в полноэкранный режим

### [](https://dev.to/scc33/how-to-find-first-and-last-position-of-element-in-sorted-array-d7f#time-complexity)Временная сложность

Каждый двоичный поиск имеет временную сложность `O(log n)`, и поскольку мы выполняем два двоичных поиска, общая временная сложность остается `O(log n)`.

Этот оптимизированный подход не только удовлетворяет алгоритмическому ограничению задачи, но и эффективно находит начальную и конечную позиции цели в массиве.
