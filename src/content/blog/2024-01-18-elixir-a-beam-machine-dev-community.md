---
title: 'Эликсир: Машина BEAM'
meta_title: 'Эликсир: Машина BEAM | Игорь Горлов - Фронтeндер'
description: >-
  Elixir молча революционизирует способы создания масштабируемых и
  поддерживаемых приложений. Созданный в 2011 году и работающий на BEAM (Björns
  Erlang Abstract
date: 2024-01-18T00:00:00.000Z
categories:
  - Обзор
author: Игорь Горлов
type: blog
draft: false
slug: lyksyr-mashyna-beam
tags:
  - Elixir
image: ../../assets/images/lyksyr-mashyna-beam-Jan-18-2024.avif
lastmod: 2024-03-20T21:26:45.835Z
---

Elixir молча революционизирует способы создания масштабируемых и поддерживаемых приложений. Созданный в 2011 году и работающий на BEAM (Björn’s Erlang Abstract Machine), Elixir - это функциональный, параллельный, высокоуровневый язык программирования общего назначения. Elixir работает на системе BEAM, которая используется для реализации платформы Erlang Open Telcom Platform (OTP), представляющей собой набор библиотек, промежуточного программного обеспечения и инструментов, расширяющих язык программирования Erlang 80-х годов.

![gt96cpq8o1zzn61yyfn0.gif](../../assets/images/gt96cpq8o1zzn61yyfn0.gif)

Разработанный Жозе Валимом, который также работал над фреймворком Ruby on Rails, язык Elixir был создан под влиянием крупномасштабной телекоммуникационной системы 1980-х годов, которая использовалась для решения массовых задач по переключению телефонов. Язык был создан, чтобы использовать сильные стороны Erlang, обеспечивая при этом более современный и расширяемый синтаксис. Он особенно хорошо подходит для создания отказоустойчивых систем с упором на производительность разработчиков в распределенных системах.

![0kzn9iapvr6gqlmv1eja.png](../../assets/images/0kzn9iapvr6gqlmv1eja.png)

Elixir используется такими известными организациями, как Discord, которая использует модель параллелизма Elixir и способность фреймворка Phoenix обеспечивать связь в реальном времени для обработки массового спроса одновременных пользователей. Также фреймворк используется компанией Motorola для повышения отказоустойчивости телекоммуникационных систем, а Pinterest - для масштабирования своих систем оповещения в реальном времени. Это предполагает обработку большого количества событий и оперативную доставку уведомлений с использованием асинхронных задач и обновлений в реальном времени. Основанный на Elixir фреймворк Phoenix отвечает за тысячи полнофункциональных веб-приложений. Веб-фреймворк Phoenix использует модель параллелизма Elixir и OTP для обеспечения высокопроизводительной и отказоустойчивой среды для начинающих приложений.

![drzn6zv5ukaijqdac3lg.png](../../assets/images/drzn6zv5ukaijqdac3lg.png)

По данным опроса разработчиков Stack Overflow (https://survey.stackoverflow.co/2023/#technology-most-popular-technologies) в этом году Elixir занимает всего 2,63% по популярности среди других языков кодирования. Хотя он и не является самым популярным языком, его нишевое применение в определенных типах приложений, особенно тех, которые требуют многопоточной обработки и низкой задержки, создало растущий рынок.

## Типы данных

Как и Ruby, Elixir является динамически типизированным языком, что означает, что типы переменных определяются во время выполнения, а не во время компиляции. Elixir предлагает большое количество типов данных, включая Integers, Floats, Atoms, Ranges, Binaries, Lists, Maps и Tuples. Комментарии можно добавлять с помощью знака фунта ”#”, который помогает нам добавлять псевдокод.

```elixir
value = 42 # Integer
IO.puts value
value = "hello" # String
IO.puts value
value = :elixir # Atom
IO.puts value
# Максимального размера int не существует
my_int = 123
IO.puts "Integer #{is_integer(my_int)}"
# Плавающие числа имеют точность около 16 знаков
my_float = 3.14159
IO.puts "Float #{is_float(my_float)}"
# Имя атома является его значением
IO.puts "Atom #{is_atom(:Pittsburgh)}"
# Используйте двойные кавычки для пробелов : "New York"
# gets извлекает пользовательский ввод
# trim удаляет новую строку
name = IO.gets("Как вас зовут? ") |> String.trim
```

После присвоения значения становятся неизменяемыми, то есть не могут быть изменены. Типы данных связываются с помощью знака равенства ”=” и являются константами. В Elixir операторы ввода/вывода записываются с помощью ключевого слова IO. Есть несколько вариантов их использования: IO.puts - это как консольный журнал, который используется для отображения конкретной переменной или оператора. IO.inspect может использоваться для печати заданного выражения на консоль для проверки. IO.gets может использоваться для запроса пользователю.

## Атомы

Атомы играют важную роль в использовании выразительности Elixir. Они представляют собой литералы, в которых имя и значение представляют собой одно и то же значение. Атомы - это неизменяемые уникальные значения, используемые в качестве констант, меток или идентификаторов.

```elixir
# вот как мы объявим в Elixir
test = "test"
IO.puts test

{:error, reason} = {:error, "500 Internal Service Error"}
IO.puts reason

{:ok, msg} = {:ok, "status 200 ok"}
IO.puts msg

def handle_result(:ok), do: "status 200 ok"
def handle_result(:error), do: "500 Internal Service Error"

IO.puts handle_result(:ok) #status 200 ok
IO.puts handle_result(:error) #500 Internal Service Error
```

Атомы объявляются с помощью цвета ”:” и могут включать в себя буквы, цифры и числа. Чаще всего используются при сопоставлении шаблонов, чтобы сделать код более выразительным и читаемым. Для сопоставления шаблонов мы используем кортежи. Кортежи могут содержать от 2 до 4 значений и не предназначены для перечисления или циклического использования, как списки при сопоставлении образцов.

## Карты

Карты похожи на объекты JavaScript и являются основной структурой ключей-значений в Elixir. Карты не накладывают никаких ограничений на тип ключа. Ключом в карте может быть что угодно.

```elixir
# Создание карты с парами ключ-значение
user = %{
  name: "Bob",
  age: 30,
  city: "Новый Орлеан"
}

# Доступ к значениям из карты
name = user[:name]
IO.puts "User's name is #{name}" # Имя пользователя - Боб

# Обновление значений в карте
updated_user = Map.put(user, :age, 31)
IO.inspect updated_user #name: "Bob", age: 31, city: "Новый Орлеан"

# Добавление пар ключ-значение в карту
new_user = %{user | city: "Батон-Руж", email: "bob@gmail.com"}
IO.inspect new_user #name: "Bob", age: 31, city: "Baton Rouge", email: "bob@gmail.com"
```

Карты создаются с помощью синтаксиса %{} и могут обеспечить эффективный доступ и манипулирование на основе ключей. Их гибкость и доступность делают их неоценимыми для работы со сложными структурами данных.

## Функции

Функции определяются с помощью ключевого слова “def”. Это ключевое слово сигнализирует о начале определения функции, после чего вы можете указать имя функции и ее различные параметры.

```elixir
defmodule Greeter do
  def greet(:world), do: IO.puts "Hello, World!"
  def greet(name), do: IO.puts "Hello, #{name}!"
end

Greeter.greet("Alex") # Hello, Alex!
Greeter.greet(:world) # Hello, World!
Greeter.greet("Bob") # Hello, Bob!
```

Функции также могут включать сопоставление шаблонов, что позволяет нам определять несколько предложений для одного и того же имени функции, делая код более выразительным и позволяя нам изменять поведение функции в зависимости от ее входных данных.

```elixir
defmodule Math do
  def add(a, b), do: a + b
  def add([]), do: 0
  def add([head | tail]), do: head + add(tail)
end
```

Этот пример позволяет нам добавить несколько условий к функции add, что позволяет нам использовать список или основные целые числа.

В заключение хочу сказать, что Elixir родился из желания объединить надежность Erlang с более современным, удобным для разработчиков синтаксисом. Фреймворк phoenix стал популярным выбором для создания веб-приложений реального времени с динамической типизацией, возможностями метапрограммирования и удобством сопровождения кода. По мере того как все больше компаний используют его для различных целей, Elixir продолжает развиваться, обеспечивая сообщество поддержки и богатый набор библиотек.

Источники:  
https://elixir-lang.org/docs.html
https://www.newthinktank.com/2017/04/learn-elixir-one-video_(программирование_языка)
