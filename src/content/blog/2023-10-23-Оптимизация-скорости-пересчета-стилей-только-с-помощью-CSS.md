---
title: Оптимизация скорости пересчета стилей только с помощью CSS
meta_title: |
  Оптимизация Скорости Пересчета Стилей Только С Помощью...
description: >
  Взаимодействие с элементами на веб-странице обычно приводит к какому-то
  результату. Например, нажатие на кнопку может открывать выпадающее меню.
  Как...
date: 2023-10-22T23:04:46.752Z
image: >-
  ../../assets/images/optimizaciya-skorosti-perescheta-stilej-tolьko-s-pomoshьyu-css-Oct-23-2023.avif
categories:
  - Учебник
author: Igor Gorlov
tags:
  - Css
draft: false
keywords: ''
type: blog
slug: optimizaciya-skorosti-perescheta-stilej-tolьko-s-pomoshьyu-css
lastmod: 2024-03-20T21:26:48.706Z
---

Взаимодействие с элементами на веб-странице обычно приводит к какому-то результату. Например, нажатие на кнопку может открывать выпадающее меню. Как разработчики, мы знаем, что происходит за кулисами в браузере. Однако пользователи могут видеть только непосредственные результаты своих действий.

Задачей браузера является максимально быстро отрисовывать веб-страницу и все ее элементы. Чем быстрее браузер рендерит страницу, тем более плавным будет опыт пользователя.

Разработчики часто имеют мощные компьютеры и быстрые сетевые соединения, и поэтому им не составляет труда загрузить веб-страницу. Не у всех есть такая возможность, поэтому вам придется учитывать пользователей с медленными компьютерами и сетями.

В этой статье мы рассмотрим, как оптимизировать пересчет стилей в CSS. Мы обсудим, как работает процесс отрисовки браузера, как ваш способ написания CSS влияет на его скорость и многое другое, включая:

<!-- wp:rank-math/toc-block {"headings":[{"key":"1269cff5-0edb-4d5b-890b-b31f7f4310fa","content":"Понимание работы отрисовки браузера","level":2,"link":"#понимание-работы-отрисовки-браузера","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"9617679c-8041-4657-8729-cc868c921e49","content":"Что такое инвалидация стилей?","level":3,"link":"#что-такое-инвалидация-стилей","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"e0a7481d-dd1c-49fe-a609-9dc24e63a440","content":"Типы инвалидации","level":3,"link":"#типы-инвалидации","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"ef001962-9bff-4461-a8bb-0d488ad7d8d8","content":"Что такое пересчет стилей?","level":3,"link":"#что-такое-пересчет-стилей","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"789f0cd4-7d54-4b14-8750-8dc3a59d1326","content":"Движки отрисовки браузера","level":3,"link":"#движки-отрисовки-браузера","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"77a8443a-c7a6-4be2-9aa8-05e5c2f0f7a5","content":"Исследование компоновки, рисования и компоновки","level":3,"link":"#исследование-компоновки-рисования-и-компоновки","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"84ea8f1f-127f-4e55-9243-fae652fac88c","content":"Оптимизация производительности стилей с помощью CSS","level":2,"link":"#оптимизация-производительности-стилей-с-помощью-css","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"b1581591-c217-460a-92cb-71257d2858ed","content":"Используйте более компактные деревья DOM","level":3,"link":"#используйте-более-компактные-деревья-dom","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"3206bb96-3c03-4dc5-b91f-95596b288824","content":"Уменьшите размер ваших таблиц стилей","level":3,"link":"#уменьшите-размер-ваших-таблиц-стилей","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"64568e31-1fde-459f-96f2-707b01d7b2e2","content":"Оптимизируйте использование селекторов","level":3,"link":"#оптимизируйте-использование-селекторов","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"5a4ab74c-2801-4c31-910a-d15fd85851f8","content":"Избегайте частых или больших мутаций DOM","level":3,"link":"#избегайте-частых-или-больших-мутаций-dom","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"2a6ad39d-4944-490f-ba26-2cbae9df9217","content":"Сравнение оптимальных и неоптимальных анимаций CSS","level":2,"link":"#сравнение-оптимальных-и-неоптимальных-анимаций-css","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"3b70777a-2a70-4101-ba4e-1cf782e4f877","content":"Заключение","level":2,"link":"#заключение","disable":false,"isUpdated":false,"isGeneratedLink":true}],"listStyle":"ul"} -->
<div class="wp-block-rank-math-toc-block" id="rank-math-toc"><nav><ul><li class=""><a href="#понимание-работы-отрисовки-браузера">Понимание работы отрисовки браузера</a><ul><li class=""><a href="#что-такое-инвалидация-стилей">Что такое инвалидация стилей?</a></li><li class=""><a href="#типы-инвалидации">Типы инвалидации</a></li><li class=""><a href="#что-такое-пересчет-стилей">Что такое пересчет стилей?</a></li><li class=""><a href="#движки-отрисовки-браузера">Движки отрисовки браузера</a></li><li class=""><a href="#исследование-компоновки-рисования-и-компоновки">Исследование компоновки, рисования и компоновки</a></li></ul></li><li class=""><a href="#оптимизация-производительности-стилей-с-помощью-css">Оптимизация производительности стилей с помощью CSS</a><ul><li class=""><a href="#используйте-более-компактные-деревья-dom">Используйте более компактные деревья DOM</a></li><li class=""><a href="#уменьшите-размер-ваших-таблиц-стилей">Уменьшите размер ваших таблиц стилей</a></li><li class=""><a href="#оптимизируйте-использование-селекторов">Оптимизируйте использование селекторов</a></li><li class=""><a href="#избегайте-частых-или-больших-мутаций-dom">Избегайте частых или больших мутаций DOM</a></li></ul></li><li class=""><a href="#сравнение-оптимальных-и-неоптимальных-анимаций-css">Сравнение оптимальных и неоптимальных анимаций CSS</a></li><li class=""><a href="#заключение">Заключение</a></li></ul></nav></div>
<!-- /wp:rank-math/toc-block -->

Позже в этой статье мы рассмотрим CSS-анимацию как специфический случай проблемы пересчета стилей, сравнив оптимальные и неоптимальные примеры анимации. Вы можете посмотреть нашу демонстрацию анимации на CodePen.

<h2 class="wp-block-heading" id="понимание-работы-отрисовки-браузера">Понимание работы отрисовки браузера</h2>

Когда веб-страница в первый раз загружается, браузер смотрит на HTML и создает древо объектов документа (DOM). Затем он смотрит на CSS и применяет его правила к соответствующим селекторам в этом древе DOM. Наконец, он выполняет JavaScript-код и отображает страницу.

Представьте себе страницу с навигационной панелью, где одна из ссылок в навигационной панели открывает выпадающее меню. Когда вы открываете это меню, браузер добавляет новый элемент на страницу. Затем он повторяет процесс получения HTML, создания элемента, применения стилей CSS и отображения его на странице.

Этот процесс может занять всего несколько секунд или даже миллисекунд, но в фоновом режиме происходит многое. Создание выпадающего меню изменяет DOM, что вызовет процесс отрисовки. Процесс отрисовки начинается с инвалидации и пересчета стилей.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="что-такое-инвалидация-стилей">Что такое инвалидация стилей?</h3>

Инвалидация - это процесс, который выявляет и помечает все элементы, которые требуют переоформления после изменения DOM.

Как только браузер находит все измененные элементы в новом дереве DOM, он создает набор инвалидации - коллекцию элементов, которые нужно переоформить после мутации. Пересчет стилей начинается после этого.

Изменение DOM также можно описать как мутацию DOM. Это включает в себя действия, такие как переключение имени класса, добавление или удаление элемента, анимации наведения и так далее.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="типы-инвалидации">Типы инвалидации</h3>

Существует два типа инвалидации: мгновенная и ожидающая.

Мгновенная инвалидация происходит, когда изменения сразу влияют на инвалидные элементы, например, переключение имени класса:

```javascript
dropdownMenu.classList.toggle('active');
```

Этот JavaScript-код переключает активный класс, который открывает и закрывает выпадающее меню. Браузер создает набор инвалидации, и так как действие должно произойти сразу после нажатия на ссылку, элементы переоформляются немедленно.

Ожидающая инвалидация происходит, когда браузер не уверен, какие элементы изменятся. Например, если вы меняете CSS-переменные, браузер создает набор инвалидации для всех элементов, использующих переменную. Однако он не пересчитывает стили сразу же.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="что-такое-пересчет-стилей">Что такое пересчет стилей?</h3>

Теперь, когда у браузера есть список инвалидных элементов, пришло время добавить стили. Браузер находит CSS-правила, применяющиеся к этим инвалидным элементам, и вычисляет их значения в процессе сопоставления селекторов:

```css
.dropdown {
	display: none;
	position: absolute;
	left: 0;
	top: 100%;
	background-color: #22232e;
}
/* Показывать выпадающее меню при нажатии на ссылку */
.dropdown.active {
	display: block;
}
```

Первый набор CSS-правил устанавливает значение display в none. Это становится недействительным, когда вы нажимаете на ссылку, потому что у нас теперь есть новый селектор класса — active — с отображением, установленным в block. Затем браузер находит и применяет новое CSS-правило перед отображением страницы:

```javascript
// Показать/скрыть выпадающее меню при нажатии на ссылку
dropdownLink.addEventListener('click', function (event) {
	event.preventDefault(); // предотвратить переход по ссылке
	dropdownMenu.classList.toggle('active');
});
```

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="движки-отрисовки-браузера">Движки отрисовки браузера</h3>

Каждый браузер имеет свой движок отрисовки с основной задачей отображать веб-страницу как можно быстрее. Этот движок управляет инвалидацией стилей и пересчетом стилей.

Blink служит движком отрисовки для Chrome и других браузеров на основе Chromium, таких как Opera и Edge. В то время как Gecko является движком отрисовки для Firefox, а WebKit — движком отрисовки для Safari.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="исследование-компоновки-рисования-и-компоновки">Исследование компоновки, рисования и компоновки</h3>

Перед тем как браузер отобразит окончательную страницу, в процессе отрисовки проходят еще три этапа: компоновка, рисование и компоновка.

<img width="730" height="411" src="https://res.cloudinary.com/practicaldev/image/fetch/s--6JmktNlG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/img1-Browser-rendering-pipeline.png" alt="Infographic Of Browser Rendering Pipeline Showing Steps In Order: Invalidation And Recalculation, Layout, Painting, Compositing, Webpage Is Visible">

Изменения в DOM могут влиять на компоновку веб-страницы. Браузеру, возможно, придется вычислить новый размер или позицию элементов на странице. Некоторые CSS-свойства, которые могут вызвать это, включают margin, border и padding.

После этапа компоновки браузер может потребоваться перерисовать элементы, которые изменились или были добавлены на страницу. Рисование включает в себя заполнение пикселей цветом.

Компоновка происходит, когда браузер объединяет разные слои веб-страницы и отображает одно окончательное изображение. Это самый быстрый и менее ресурсозатратный процесс.

<h2 class="wp-block-heading" id="оптимизация-производительности-стилей-с-помощью-css">Оптимизация производительности стилей с помощью CSS</h2>

Как мы видели, браузер управляет пересчетом стилей с помощью движка отрисовки. Мы не можем непосредственно наблюдать, как это происходит, или видеть, как это работает, но мы знаем, что способ, которым вы обрабатываете свой CSS, может влиять на скорость пересчета стилей. Давайте рассмотрим несколько примеров.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="используйте-более-компактные-деревья-dom">Используйте более компактные деревья DOM</h3>

Большие и глубокие деревья DOM могут замедлить производительность. Если есть слишком много элементов HTML, браузеру потребуется больше времени для отрисовки страницы:

```html
<div id="container">
	<div class="header">
		<h1>Это заголовок</h1>
	</div>
	<div class="content">Это абзац</div>
	<div class="footer">Это нижний колонтитул</div>
</div>
```

Использование более семантических элементов вместо постоянного использования div может помочь создать более компактное дерево DOM:

```html
<header>
	<h1>Это заголовок</h1>
</header>
<article>Это абзац</article>
<footer>Это нижний колонтитул</footer>
```

Иметь более компактное дерево DOM также снизит количество инвалидации после мутации. Семантика помогает браузеру понять назначение элемента и ускорить его отображение. Код также становится более читаемым.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="уменьшите-размер-ваших-таблиц-стилей">Уменьшите размер ваших таблиц стилей</h3>

Меньшее количество CSS-правил упрощает работу браузера, уменьшая количество инвалидаций и оптимизируя пересчет стилей. Использование CSS-переменных может помочь избежать повторяющегося кода.

Предположим, что у header и footer одинаковый цвет фона:

```css
header {
	background-color: #00c2cb;
}
footer {
	background-color: #00c2cb;
}
/Альтернатива/ header,
footer {
	background-color: #00c2cb;
}
```

Если происходит мутация, которая затрагивает их обоих, например, изменение тем, браузер создаст два набора инвалидации. Когда используются CSS-переменные, браузер создает единый набор инвалидации для каждого элемента, использующего эту переменную:

```css
:root {
	--bg-color: #00c2cb;
}

header,
footer {
	background-color: var(--bg-color);
}
```

Препроцессор, такой как Sass, также может дополнительно поддерживать этот процесс.

Если на вашей странице слишком много элементов и их нельзя уменьшить, рассмотрите возможность использования нескольких таблиц стилей.

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="оптимизируйте-использование-селекторов">Оптимизируйте использование селекторов</h3>

Браузеры больше обращают внимание на селекторы, чем на применяемые к ним CSS-правила. Без селекторов браузер не знал бы, что стилизовать в первую очередь. Если селекторы слишком сложные или неспецифичные, это может занять больше времени для отрисовки страницы.

Поэтому лучше быть специфичными при использовании селекторов — например, использовать селекторы класса и идентификатора для целирования элементов. Примеры неспецифичных селекторов включают \*, div, p, a и так далее.

Также избегайте селекторов потомков, так как они могут потребовать от браузера инвалидации многих дочерних элементов. Если вы хотите выбрать вложенный элемент, вам придется использовать правило вида .a .b {...}:

```html
<div>Лорем, ипсум долор сит амет консектетур адиписичинг элит.</div>
```

Если вы хотите стилизовать эти элементы, вот как это можно сделать:

```css
div {
/CSS-правила/
}
div p {
/CSS-правила/
}

```

С изменением браузер должен будет инвалидировать как родительские, так и дочерние элементы. Как и в предыдущем примере, это означает два набора инвалидации. Браузер читает справа налево, по мере продвижения вверх по DOM, поэтому сначала он найдет элемент p и затем перейдет к div.

В отличие от этого, с одним конкретным селектором браузер может сосредотачиваться только на его соответствии CSS-правилам:

```html
<div>
	<p class="text">Лорем, ипсум долор сит амет консектетур адиписичинг элит.</p>
</div>
```

С конкретным именем класса, вот как можно стилизовать абзац:

```css
.text{
/CSS-правила/
}


```

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="избегайте-частых-или-больших-мутаций-dom">Избегайте частых или больших мутаций DOM</h3>

Изменение одновременно многих элементов или частые изменения замедлят процесс отрисовки. Частые мутации означают, что браузер должен создавать больше наборов инвалидации для каждого затронутого элемента.

Держитесь в пределах разумных рамок с анимациями или используйте их только для интерактивных элементов.

<h2 class="wp-block-heading" id="сравнение-оптимальных-и-неоптимальных-анимаций-css">Сравнение оптимальных и неоптимальных анимаций CSS</h2>

Один из способов внесения изменений в DOM — это анимация с использованием CSS. Браузер анимирует свойства CSS по-разному, и некоторые методы требуют больше системных ресурсов, чем другие.

Посмотрите следующую <a href="https://codepen.io/oscar-jite/pen/JjwjOry">анимацию на CodePen</a>.

Они выглядят одинаково, верно? Но браузер выполняет больше работы для отрисовки правого блока.

Для первого блока анимируется свойство transform, и оно транслируется вдоль оси Y на -20px. Для второго блока анимируется свойство margin-top и изменяется на -20px.

Вот HTML:

```html
<body>
	<div class="box"></div>
	<div class="box-2"></div>
</body>
```

И вот CSS:

```css
div {
	height: 250px;
	width: 200px;
	background: #00c2cb;
	border: 2px solid #22232e;
	border-radius: 20px;
	margin: 20px;
}
.box {
	animation: translate 1s infinite alternate;
}
.box-2 {
	animation: margin 1s infinite alternate;
}
@keyframes translate {
	100% {
		transform: translateY(-20px);
	}
}
@keyframes margin {
	100% {
		margin-top: -20px;
	}
}
```

На любом браузере на основе Chromium откройте инспектор и нажмите на три точки в правом верхнем углу вкладки. Выберите Дополнительные инструменты, затем Отрисовка и, наконец, Мигание при рисовании:

<img width="730" height="411" src="https://res.cloudinary.com/practicaldev/image/fetch/s--VhsjDh7X--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/img2-Chromium-browser-devtools-Paint-Flashing.png" alt="Screenshot Of Chromium Browser Devtools Showing How To Enable Paint Flashing">

Эта настройка покажет вам, когда браузер выполняет процесс рисования, мигая зеленым цветом. Обратите внимание, что вы можете не видеть мигание при рисовании в CodePen, поэтому вам, возможно, стоит использовать живой предпросмотр.

Вот запись анимации с выбранной опцией мигания при рисовании:

<img width="730" height="411" data-animated="true" src="https://res.cloudinary.com/practicaldev/image/fetch/s--JOg9gU7e--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/img3-Animation-paint-flashing-selected.gif" alt="Two Animated Squares Side By Side With Paint Flashing Selected">

Браузеру приходится постоянно перерисовывать блок справа с помощью анимации margin на каждом кадре анимации. Это означает, что для отрисовки этого блока используется больше ресурсов, что может быть проблемой на медленном компьютере.

Мы также можем использовать вкладку Производительность в инструментах разработчика вашего браузера на основе Chromium, чтобы отслеживать, сколько времени занимает каждый этап в процессе отрисовки. С использованием вкладки Производительность вы можете анализировать, какие операции в вашей веб-странице занимают больше времени.

Изменение оптимальной анимации на анимацию с transform:

<img width="730" height="411" src="https://res.cloudinary.com/practicaldev/image/fetch/s--4qkNikAn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/img4-Performance-data-box-transform-animation.png" alt="Performance Data From Browser Devtools For Box Animated With Transform Property">

Запись длится около пяти секунд. Обратите внимание, что мы устанавливаем снижение производительности CPU в 6 раз медленнее, чтобы имитировать работу пользователя на медленном устройстве или с медленным сетевым подключением.

Как видно, отрисовка заняла 778 миллисекунд, включая компоновку и сведение слоев. Рисование заняло 480 миллисекунд. Также имеется 1877 миллисекунд простоя.

Теперь рассмотрим данные для блока, анимированного с использованием свойства margin-top:

 <img width="730" height="411" src="https://res.cloudinary.com/practicaldev/image/fetch/s--w9gcBj6V--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/Performance-data-box-animated-transform-property.png" alt="Performance Data From Browser Devtools For Box Animated Using Margin Top Property">

Здесь имеется значительная разница в скорости. Время отрисовки сократилось до всего 12 миллисекунд, а рисование уменьшилось до 13 миллисекунд. При этом браузер простаивает в течение 4471 миллисекунд — это много времени простоя для браузера.

Мы можем ближе рассмотреть анимацию с использованием свойства margin-top, выделив небольшой участок. Вы можете наблюдать, когда вызываются пересчеты стилей и как долго они занимают:

<img width="730" height="492" data-animated="true" src="https://res.cloudinary.com/practicaldev/image/fetch/s--ONr8I52M--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_800/https://blog.logrocket.com/wp-content/uploads/2023/09/img5-Margin-animation-small-section-highlighted.gif" alt="Small Section Of Margin Animation Performance Data In Browser Devtools Highlighted To Show When Style Recalculations Are Triggered And How Long They Take">

Все это отсутствует в анимации с использованием свойства transform.

Это всего лишь один специфический случай, но другие свойства, которые не вызывают шаги компоновки или рисования, включают opacity и filter. Элемент с установленным значением display: none все равно виден браузеру, поэтому я бы посоветовал использовать opacity с самого начала.

К сожалению, не существует четкого списка свойств, потребляющих много ресурсов. Уменьшайте размер ваших таблиц стилей, оптимизируйте селекторы и не увлекайтесь CSS-анимациями, и у вас все будет в порядке.

<h2 class="wp-block-heading" id="заключение">Заключение</h2>

Как говорит нам эффект бабочки, небольшие изменения (в вашем CSS) могут оказать огромное влияние в других местах (на производительность вашего приложения). В этой статье мы рассмотрели, как браузер отрисовывает страницу после любого изменения, что может вызвать проблемы с производительностью и что можно сделать, чтобы избежать таких проблем.

Также важно слушать жалобы пользователей, так как они лучше всего знают, что не работает должным образом на стороне клиента. Оптимизация пересчета стилей с помощью CSS может помочь улучшить пользовательский опыт и обеспечить правильное отображение веб-страницы даже для пользователей с медленными устройствами или сетевыми подключениями.
