<!DOCTYPE html><html lang="ru"> <head><title>5 инструментов автоматической проверки для Rust и когда использовать каждый из них | Игорь Горлов - Фронтeндер</title><link rel="canonical" href="https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh"><meta name="description" content="Rust  популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию примен"><meta name="robots" content="index, follow"><!-- favicon --><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><!-- theme meta --><meta name="theme-name" content="igorlov.ru"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="generator" content="Astro v4.10.0"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- responsive meta --><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><meta name="google-adsense-account" content="ca-pub-0634695143666394"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/_regular_.Dg72Zwgc.css">
<style>.breadcrumbs[data-astro-cid-vcbh62el]{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#0d52a1;color:rgba(13,82,161,var(--tw-text-opacity));border-radius:min(1.5rem,1.1625rem + .45vw)}.breadcrumbs[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.container[data-astro-cid-vcbh62el]{padding:min(2rem,1.2125rem + 1.05vw)}.list[data-astro-cid-vcbh62el]{display:flex;align-items:center;gap:.125rem}.link[data-astro-cid-vcbh62el]{font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s;padding:.125rem .75rem;font-size:min(1.5rem,1.1625rem + .45vw);line-height:var(--tw-lh)}
</style>
<link rel="stylesheet" href="/_astro/_single_.CzD8Xhhr.css">
<style>.circular-pagination[data-astro-cid-ihkjvfsn]{display:flex;width:100%;flex-wrap:wrap;align-items:center;justify-content:center;overflow:hidden;border-top-width:1px;--tw-border-opacity: 1;border-color:#27292d;border-color:rgba(39,41,45,var(--tw-border-opacity));margin-top:min(1.25rem,1.1375rem + .15vw)}.circular-pagination__link[data-astro-cid-ihkjvfsn]{width:100%;--tw-text-opacity: 1;color:#27292d;color:rgba(39,41,45,var(--tw-text-opacity));text-decoration-line:none}.circular-pagination__link[data-astro-cid-ihkjvfsn]:hover{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.circular-pagination__link[data-astro-cid-ihkjvfsn]{padding-left:min(1.5rem,1.1625rem + .45vw);padding-right:min(1.5rem,1.1625rem + .45vw);padding-top:.5rem;padding-bottom:.5rem}
.comments[data-v-f9c4118f]{margin:auto;margin-top:1.25rem;width:100%;--tw-text-opacity: 1;color:#27292d;color:rgba(39,41,45,var(--tw-text-opacity))}.comments:where([class=dark][data-v-f9c4118f],[class=dark] *[data-v-f9c4118f]){--tw-text-opacity: 1;color:#27292d;color:rgba(39,41,45,var(--tw-text-opacity))}.giscus-frame[data-v-f9c4118f]{width:100%;--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#27292d;color:rgba(39,41,45,var(--tw-text-opacity))}.giscus-frame:where([class=dark][data-v-f9c4118f],[class=dark] *[data-v-f9c4118f]){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity))}
</style><script type="module" src="/_astro/hoisted.CUFolni_.js"></script><style>[data-astro-transition-scope="astro-xdjatz7t-1"] { view-transition-name: blog-image-5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh; }</style></head> <body class="flex min-h-screen flex-col bg-gray-light pt-16 font-inter text-blue fluid:text-lg lg:pt-24 dark:bg-black dark:text-white"> <header class="header" data-astro-cid-rq644orq> <div class="header__container container" data-astro-cid-rq644orq> <a href="/" class="logo font-medium lowercase transition-colors fluid:text-lg header__logo dark:hover:text-light text-blue dark:text-white" aria-label="logo" data-astro-cid-ijoll5s5> <svg width="1.44em" height="1em" viewBox="0 0 5660 3931" class="icon" data-astro-cid-ijoll5s5 data-icon="logo-one">  <symbol id="ai:local:logo-one"><g fill="currentColor"><path d="M1198.57 596.749c0 329.575-267.171 596.751-596.747 596.751-329.575 0-596.749-267.176-596.749-596.751S272.248 0 601.823 0c329.576 0 596.747 267.174 596.747 596.749Z"/><circle cx="3035.75" cy="617.751" r="596.749" transform="rotate(-90 3035.75 617.751)"/><path d="M3035.75 2736.81c329.57 0 596.75 267.18 596.75 596.75 0 329.58-267.18 596.75-596.75 596.75-329.58 0-596.75-267.17-596.75-596.75 0-329.57 267.17-596.75 596.75-596.75Z"/><circle cx="596.749" cy="1964.8" r="596.749"/><path d="M1193.5 3332.87c0 329.57-267.176 596.75-596.751 596.75S0 3662.44 0 3332.87c0-329.58 267.174-596.75 596.749-596.75 329.575 0 596.751 267.17 596.751 596.75Z"/><circle cx="5062.46" cy="617.751" r="596.749" transform="rotate(-90 5062.46 617.751)"/><circle cx="5062.46" cy="3333.56" r="596.749" transform="rotate(-90 5062.46 3333.56)"/></g></symbol><use xlink:href="#ai:local:logo-one"></use>  </svg>  </a> <div class="nav header__nav" data-astro-cid-7wkmezxd> <button class="nav__open" title="Открыть меню" data-astro-cid-7wkmezxd> Меню</button> <nav class="nav__container" data-astro-cid-7wkmezxd> <button class="nav__close" title="Закрыть меню" data-astro-cid-7wkmezxd> Закрыть</button> <ul class="nav__list" data-astro-cid-7wkmezxd> <li class="nav__item" data-astro-cid-7wkmezxd> <a href="/blog" class="nav__link nav__link--active" data-astro-cid-7wkmezxd> Блог </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="#cta" class="nav__link" data-astro-cid-7wkmezxd> Контакты </a> </li> </ul> </nav> </div>   <!-- <ThemeToggle client:only /> --> </div> </header>  <main id="main-content" class="main flex-1">  <div class="blocks"> <nav aria-label="Breadcrumbs" class="breadcrumbs" data-astro-cid-vcbh62el> <div class="container" data-astro-cid-vcbh62el> <ol class="list" role="list" data-astro-cid-vcbh62el> <li class="item" role="listitem" data-astro-cid-vcbh62el> <a class="link" href="/" data-astro-cid-vcbh62el> Главная </a> </li><li class="item" role="listitem" data-astro-cid-vcbh62el> <a class="link" href="/blog" data-astro-cid-vcbh62el> Blog </a> </li><li class="item" role="listitem" data-astro-cid-vcbh62el>  </li> </ol> </div> </nav>  <!-- <TextAds class="fade-in-bottom fluid:my-2" style="--delay: .8s;" /> --><article class="article" data-astro-cid-axzg2cw6> <article data-astro-cid-axzg2cw6> <figure class="article__image" data-astro-cid-axzg2cw6> <picture data-astro-cid-axzg2cw6> <source srcset="/_astro/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh-Jan-02-2024.DQkrTjHc_Ws4eX.avif" type="image/avif"><source srcset="/_astro/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh-Jan-02-2024.DQkrTjHc_ZYp9F0.webp" type="image/webp"> <img src="/_astro/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh-Jan-02-2024.DQkrTjHc_1R0n3e.png" alt="5 инструментов автоматической проверки для Rust и когда использовать каждый из них" class="aspect-video h-full w-full object-cover object-center" loading="eager" data-astro-cid-axzg2cw6 data-astro-transition-scope="astro-xdjatz7t-1" width="1120" height="580" decoding="async"> </picture> </figure> </article> <div class="container" data-astro-cid-axzg2cw6> <div class="article__header" data-astro-cid-axzg2cw6> <ul class="article__categories categories" data-astro-cid-axzg2cw6> <li class="categories__item" data-astro-cid-axzg2cw6> <a href="/category/обзор" class="categories__link" data-astro-cid-axzg2cw6> Обзор  </a> </li> </ul> <h1 class="article__title text-wrap" data-astro-cid-axzg2cw6> 5 инструментов автоматической проверки для Rust и когда использовать каждый из них </h1> <ul class="article__tags tags" data-astro-cid-axzg2cw6> <li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/rust" data-astro-cid-axzg2cw6> Rust </a> </li> </ul> <time class="article__date" data-astro-cid-axzg2cw6>
Опубликовано 02 янв., 2024 by Игорь Горлов </time> <time class="article__date" data-astro-cid-axzg2cw6> Последнее изменение: 21 мар., 2024 </time> </div> <div class="article__content prose prose-zinc max-w-full break-words text-blue dark:prose-invert prose-headings:text-blue prose-p:text-balance prose-a:no-underline hover:prose-a:underline prose-figure:bg-gray-light prose-figure:p-10 prose-figcaption:text-dark dark:prose-figure:bg-dark dark:prose-figcaption:text-white" data-astro-cid-axzg2cw6> <!-- <TextAds /> --> <!-- <AdfoxTocAds blockId="adfox_17062261612859555" /> --> <div class="article__meta" data-astro-cid-axzg2cw6> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=5 инструментов автоматической проверки для Rust и когда использовать каждый из них&url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh&title=5 инструментов автоматической проверки для Rust и когда использовать каждый из них&summary=Rust  популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию примен&source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh&media=&description=Rust  популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию примен" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <a class="article__meta-section" href="#comments" data-astro-cid-axzg2cw6> Комментарии</a> </div> <details open class="toc border-b border-blue text-blue fluid:p-8 overflow-auto cursor-pointer bg-box"><summary class="toc__title text-xl font-medium">Содержание</summary><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#cargo-fuzz">cargo-fuzz</a></li><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#кани">Кани</a></li><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#proptest">Proptest</a></li><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#rust-klee">Rust Klee</a></li><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#haybale">Haybale</a></li><li class="toc-item toc-item-h2"><a class="text-blue text-blue-h2" href="#заключение">Заключение</a></li></ol></details open><p>Rust - популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию применяет лучшие практики. Несмотря на все эти удивительные особенности, он не идеален - как и любой другой язык, - и логика вашего кода иногда может вызывать неожиданное поведение.</p>
<p>Можно написать синтаксически корректный, но по своей сути баговый код. Например, может произойти ничего не подозревающее арифметическое переполнение. Вот тут-то и пригодятся инструменты автоматической проверки кода.</p>
<p>Автоматическая верификация - это техника, которая помогает доказать, что программа удовлетворяет определенным свойствам, таким как безопасность памяти и отсутствие ошибок во время выполнения. Кроме того, инструменты автоматической верификации позволяют проверять корректность параллельного кода, который бывает сложно протестировать вручную.</p>
<p>Автоматическая верификация особенно важна для Rust, поскольку она может помочь гарантировать, что небезопасный код используется правильно. В этом руководстве мы рассмотрим пять лучших инструментов проверки Rust - без особого порядка - и то, как они могут помочь вам создать более надежное программное обеспечение.</p>
<p>Помните, что, хотя сообщество Rust активно работает над развитием и улучшением инструментов автоматической верификации Rust, область инструментов автоматической верификации в целом все еще находится в процессе развития.</p>
<p>Ознакомьтесь со сравнительной таблицей в конце статьи, чтобы узнать, какие из этих инструментов готовы к производству на момент написания статьи.</p>
<h2 id="cargo-fuzz"><code>cargo-fuzz</code><a aria-hidden="true" tabindex="-1" href="#cargo-fuzz"><span class="icon icon-link"></span></a></h2>
<p>Первый инструмент, который мы рассмотрим, <code>cargo-fuzz</code>, использует технику, называемую fuzzing, для автоматизированного тестирования программного обеспечения. Предоставляя программе множество правильных, почти правильных или неправильных входных данных, fuzzing может помочь разработчикам найти нежелательное поведение или уязвимости.</p>
<p>Когда мы пишем тесты, мы обычно учитываем только несколько входов и пишем тесты, основываясь на том, как, по нашему мнению, будет реагировать система. Такой подход может привести к пропуску ошибок, особенно тех, которые вызваны неожиданными или неправильно сформированными входными данными.</p>
<p>Фаззинг может помочь вам найти эти пропущенные ошибки, предоставляя программе широкий спектр входных данных, включая недопустимые и неожиданные. Если программа дает сбой или ведет себя необычно в ответ на один из этих входов, это сигнализирует о наличии ошибки.</p>
<p>Крейт Rust <code>cargo-fuzz</code> может помочь вам в фазз-тестировании кода Rust. Он работает, генерируя случайные входные данные и подавая их в функцию, которую вы хотите протестировать. Если функция паникует или терпит крах, <code>cargo-fuzz</code> сохранит входные данные, которые вызвали сбой.</p>
<p>Вот пример того, как использовать <code>cargo-fuzz</code> для фазз-тестирования функции Rust:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#A6ACCD">#[macro_use]</span></span>
<span class="line"><span style="color:#91B4D5">extern</span><span style="color:#5DE4C7"> crate libfuzzer_sys</span><span style="color:#A6ACCD">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADD7FF">fuzz_target!</span><span style="color:#A6ACCD">(</span><span style="color:#91B4D5">|</span><span style="color:#E4F0FB">data</span><span style="color:#91B4D5">:</span><span style="color:#91B4D5"> &#x26;</span><span style="color:#A6ACCD">[</span><span style="color:#A6ACCDC0">u8</span><span style="color:#A6ACCD">]</span><span style="color:#91B4D5">|</span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#91B4D5">    let</span><span style="color:#E4F0FB"> json_string</span><span style="color:#91B4D5"> =</span><span style="color:#91B4D5"> std::</span><span style="color:#A6ACCDC0">str</span><span style="color:#91B4D5">::</span><span style="color:#ADD7FF">from_utf8</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">data</span><span style="color:#A6ACCD">)</span><span style="color:#91B4D5">.</span><span style="color:#ADD7FF">unwrap</span><span style="color:#A6ACCD">();</span></span>
<span class="line"><span style="color:#91B4D5">    let</span><span style="color:#E4F0FB"> _</span><span style="color:#91B4D5"> =</span><span style="color:#91B4D5"> serde_json::</span><span style="color:#ADD7FF">from_str</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">&#x3C;</span><span style="color:#91B4D5">serde_json::</span><span style="color:#A6ACCDC0">Value</span><span style="color:#A6ACCD">>(</span><span style="color:#91B4D5">&#x26;</span><span style="color:#E4F0FB">json_string</span><span style="color:#A6ACCD">)</span><span style="color:#91B4D5">.</span><span style="color:#ADD7FF">unwrap</span><span style="color:#A6ACCD">();</span></span>
<span class="line"><span style="color:#A6ACCD">});</span></span>
<span class="line"></span></code></pre>
<p>Приведенный выше код тестирует парсер JSON, подавая ему случайные входные данные. Цель <code>fuzz_target</code> будет вызываться до тех пор, пока не встретит входной сигнал, который вызовет панику и приведет к краху.</p>
<p>В отчете о сбое сообщается, где и почему произошла паника. Например:</p>
<p>Из приведенного отчета видно, что паника произошла, когда программа попыталась вызвать функцию <code>Result::unwrap()</code> на значении <code>Error</code>. Она запаниковала со следующей ошибкой:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="sh"><code><span class="line"><span style="color:#91B4D5">Error(</span><span style="color:#91B4D5">"EOF while parsing a value"</span><span style="color:#91B4D5">,</span><span style="color:#ADD7FF"> line:</span><span style="color:#ADD7FF"> 1,</span><span style="color:#ADD7FF"> column:</span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">);</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<p>Эта информация поможет вам провести дальнейшее расследование, чтобы определить, не вызвана ли ошибка плохим вводом, который ваш код не смог обработать. Благодаря <code>cargo-fuzz</code> у вас будет возможность исправить это.</p>
<p>Не забывайте, что некоторые из ошибок, которые вы обнаружите с помощью фаззинга, могут оказаться непрактичными или неприменимыми в реальной жизни, а значит, фаззинг может генерировать ложные срабатывания. Кроме того, фаззинг может быть ресурсоемким, особенно если речь идет о большой или сложной кодовой базе.</p>
<h2 id="кани">Кани<a aria-hidden="true" tabindex="-1" href="#кани"><span class="icon icon-link"></span></a></h2>
<p>Kani - это современный инструмент автоматической проверки кода, который поможет вам проверить корректность вашего Rust-кода за считанные секунды. Он использует технику, называемую проверкой модели, которая позволяет исследовать все возможные и невозможные состояния программы, включая состояния, недостижимые при обычном выполнении.</p>
<p>Проверка моделей позволяет Kani обнаружить проблемы в вашем коде, которые могут быть вызваны логикой с непредвиденными последствиями. Вы также можете использовать Kani для выявления других проблем, которые трудно или невозможно обнаружить с помощью других методов модульного тестирования, интеграционного тестирования или даже ручного тестирования.</p>
<p>Рассмотрим приведенный ниже код:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#5DE4C7">fn</span><span style="color:#ADD7FF"> product</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">a</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">b</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">-></span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD"> { </span><span style="color:#E4F0FB">a</span><span style="color:#91B4D5"> *</span><span style="color:#E4F0FB"> b</span><span style="color:#A6ACCD"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<p>Вы согласитесь со мной, что приведенный выше код - это правильный код на языке Rust, верно? Посмотрите на него еще раз - можете ли вы найти что-нибудь, что может пойти не так в этом коде?</p>
<p>Давайте воспользуемся Kani, чтобы выяснить это:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#5DE4C7">fn</span><span style="color:#ADD7FF"> product</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">num1</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">num2</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">-></span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#E4F0FB">    num1</span><span style="color:#91B4D5"> *</span><span style="color:#E4F0FB"> num2</span></span>
<span class="line"><span style="color:#A6ACCD">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">#[kani</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">proof]</span></span>
<span class="line"><span style="color:#5DE4C7">fn</span><span style="color:#ADD7FF"> main</span><span style="color:#A6ACCD">() {</span></span>
<span class="line"><span style="color:#91B4D5">    let</span><span style="color:#E4F0FB"> num1</span><span style="color:#91B4D5"> =</span><span style="color:#91B4D5"> kani::</span><span style="color:#ADD7FF">any</span><span style="color:#A6ACCD">();</span></span>
<span class="line"><span style="color:#91B4D5">    let</span><span style="color:#E4F0FB"> num2</span><span style="color:#91B4D5"> =</span><span style="color:#91B4D5"> kani::</span><span style="color:#ADD7FF">any</span><span style="color:#A6ACCD">();</span></span>
<span class="line"><span style="color:#91B4D5">    let</span><span style="color:#E4F0FB"> result</span><span style="color:#91B4D5"> =</span><span style="color:#ADD7FF"> product</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">num1</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">num2</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">}</span></span>
<span class="line"></span></code></pre>
<p>В приведенном выше коде мы использовали Kani для доказательствачто код корректен и в нем нет ошибок. Кани даст нам следующий ответ:</p>
<p>Все вроде бы правильно, за исключением того, что Kani обнаруживает возможность переполнения в процессе умножения.</p>
<p>Это происходит потому, что функция <code>product</code> не гарантирует, что мы не превысим максимальное значение i32, которое составляет <code>2,147,483,647</code> - все, что больше этого значения, приведет к ошибке. По сути, все, для чего будет использоваться эта функция, не сможет работать с числами, превышающими два миллиарда.</p>
<p>В этом случае использование Kani для выявления этой потенциальной проблемы позволяет либо сразу изменить тип данных, либо оставить все как есть и правильно обработать ошибку, если это ожидаемое поведение.</p>
<p>Как и любой другой инструмент, Kani имеет свои ограничения. К счастью, эти ограничения достаточно хорошо задокументированы. Они варьируются от неопределенного поведения до некоторых неподдерживаемых функций в Rust.</p>
<h2 id="proptest">Proptest<a aria-hidden="true" tabindex="-1" href="#proptest"><span class="icon icon-link"></span></a></h2>
<p>Proptest позволяет проверить свойства функции с помощью множества допустимых и недопустимых входных данных, чтобы найти ошибки. Это отличается от классических методов тестирования, таких как модульное тестирование, где вы указываете некоторые входные данные и добавляете утверждения, основанные на ожидаемом поведении.</p>
<p>Тестирование свойств - это форма fuzz-тестирования, которая более контролируема и сосредоточена на проверке конкретных свойств. Это делает его хорошим выбором для тестирования сложных систем, где традиционное фазз-тестирование может быть слишком медленным или неэффективным.</p>
<p>Давайте рассмотрим, как можно использовать крейт Rust Proptest:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#5DE4C7">use</span><span style="color:#91B4D5"> proptest::prelude::</span><span style="color:#A6ACCD">{any, proptest};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#5DE4C7">fn</span><span style="color:#ADD7FF"> add_two_numbers</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">first_number</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">second_number</span><span style="color:#91B4D5">:</span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">-></span><span style="color:#A6ACCDC0"> i32</span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#E4F0FB">    first_number</span><span style="color:#91B4D5"> +</span><span style="color:#E4F0FB"> second_number</span></span>
<span class="line"><span style="color:#A6ACCD">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADD7FF">proptest!</span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#A6ACCD">    #[test]</span></span>
<span class="line"><span style="color:#5DE4C7">    fn</span><span style="color:#ADD7FF"> test_add_two_numbers</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">first_number</span><span style="color:#5DE4C7"> in</span><span style="color:#ADD7FF"> any</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">&#x3C;</span><span style="color:#A6ACCDC0">i32</span><span style="color:#A6ACCD">>(), </span><span style="color:#E4F0FB">second_number</span><span style="color:#5DE4C7"> in</span><span style="color:#ADD7FF"> any</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">&#x3C;</span><span style="color:#A6ACCDC0">i32</span><span style="color:#A6ACCD">>()) {</span></span>
<span class="line"><span style="color:#91B4D5">        let</span><span style="color:#E4F0FB"> expected</span><span style="color:#91B4D5"> =</span><span style="color:#E4F0FB"> first_number</span><span style="color:#91B4D5"> +</span><span style="color:#E4F0FB"> second_number</span><span style="color:#A6ACCD">;</span></span>
<span class="line"><span style="color:#91B4D5">        let</span><span style="color:#E4F0FB"> actual</span><span style="color:#91B4D5"> =</span><span style="color:#ADD7FF"> add_two_numbers</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">first_number</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">second_number</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#ADD7FF">        assert_eq!</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">actual</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">expected</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">    }</span></span>
<span class="line"><span style="color:#A6ACCD">}</span></span>
<span class="line"></span></code></pre>
<p>В приведенном выше коде мы тестируем простую функцию, которая складывает два числа. Что может пойти не так с такой простой функцией?</p>
<p>Давайте посмотрим на сигнатуру функции <code>test_add_two_numbers</code>:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#5DE4C7">fn</span><span style="color:#ADD7FF"> test_add_two_numbers</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">first_number</span><span style="color:#5DE4C7"> in</span><span style="color:#ADD7FF"> any</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">&#x3C;</span><span style="color:#A6ACCDC0">i32</span><span style="color:#A6ACCD">>(), </span><span style="color:#E4F0FB">second_number</span><span style="color:#5DE4C7"> in</span><span style="color:#ADD7FF"> any</span><span style="color:#91B4D5">::</span><span style="color:#A6ACCD">&#x3C;</span><span style="color:#A6ACCDC0">i32</span><span style="color:#A6ACCD">>())</span></span>
<span class="line"></span></code></pre>
<p>Стратегия <code>any::&#x3C;i32>()</code> - это стратегия Proptest, которая генерирует случайные значения i32, как допустимые, так и недопустимые. Это позволяет нам тестировать функцию <code>add_two_numbers()</code> с широким диапазоном входных данных, включая крайние случаи и аномалии.</p>
<p>Тестовая функция Proptest будет генерировать большое количество случайных входов для параметров <code>первое_число</code> и <code>второе_число</code>.</p>
<p>Для каждого входа тест утверждает, что фактический вывод функции <code>add_two_numbers()</code> равен ожидаемому. Если какой-либо из тестов не сработает, Proptest выведет в консоль неудачные входы.</p>
<p>Вот пример того, как Proptest может генерировать входные данные для функции <code>test_add_two_numbers()</code>:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="sh"><code><span class="line"><span style="color:#A6ACCD">(</span><span style="color:#91B4D5">10,</span><span style="color:#5DE4C7"> 20</span><span style="color:#A6ACCD">) (</span><span style="color:#91B4D5">-100,</span><span style="color:#5DE4C7"> 100</span><span style="color:#A6ACCD">) (</span><span style="color:#91B4D5">1234567890,</span><span style="color:#5DE4C7"> 9876543210</span><span style="color:#A6ACCD">) (</span><span style="color:#91B4D5">0,</span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">) (</span><span style="color:#91B4D5">-1,</span><span style="color:#ADD7FF"> -1</span><span style="color:#A6ACCD">) (</span><span style="color:#91B4D5">std::i32::MIN,</span><span style="color:#ADD7FF"> std::i32::MAX</span><span style="color:#A6ACCD">)</span></span>
<span class="line"></span></code></pre>
<p>Если тест не работает с определенными входными данными, Proptest также уменьшит входные данные. Например, если тест провалился с входом <code>(10, 20)</code>, Proptest может повторить попытку с входом <code>(5, 10)</code> или даже <code>(1, 2)</code>. Это помогает определить наименьший возможный вход, который приводит к неудаче теста.</p>
<p>Когда мы запускаем тест, мы получаем отчет о неудачном тестировании, как показано ниже:</p>
<p>Отчет показывает, что существует вероятность переполнения. Он также показывает минимальный воспроизводимый ввод. С этой информацией мы можем приступить к исправлению ошибки.</p>
<p>Хотя тестирование свойств может работать очень хорошо для определенного диапазона входных данных, иногда оно может пропустить некоторые крайние случаи и дать вам ложноположительный или ложноотрицательный результат. Другими словами, он может галлюцинировать ошибки там, где их на самом деле нет, или не найти ошибку за пределами заданного покрытия.</p>
<h2 id="rust-klee">Rust Klee<a aria-hidden="true" tabindex="-1" href="#rust-klee"><span class="icon icon-link"></span></a></h2>
<p>KLEE - это механизм символьного выполнения, который позволяет интеллектуально исследовать все пути кода в вашей программе для обнаружения уязвимостей или ошибок. Он построен на основе инфраструктуры компилятора LLVM, который написан на языках C и C++.</p>
<p>Как следствие, большинство реализаций KLEE также написаны на C и C++. Однако фундаментальные концепции KLEE могут быть реализованы на любом языке программирования.</p>
<p>Rust Klee - это реализация KLEE на языке Rust с открытым исходным кодом. Как и другие инструменты верификации, о которых мы рассказывали в этом руководстве, Rust Klee был разработан для проверки определенных свойств. В частности, согласно сообщению в блоге автора пилотного проекта, он был разработан для:</p>
<p>Проверки безопасности Инварианты Параметризованные проверки Проверка функциональной корректности программ на Rust</p>
<p>Это делает его более целенаправленным и эффективным, чем некоторые другие инструменты верификации, которые могут быть более универсальными.универсального назначения.</p>
<p>Однако в той же записи в блоге пилота автор предупреждает, что целью его проекта никогда не было ”создание системы верификации, готовой к интеграции в любой проект”. Фактически, репозиторий не обновлялся уже четыре года, и, похоже, дальнейшее развитие не планируется.</p>
<p>Скорее, целью автора Rust Klee было исследовать, можно ли применить инструменты верификации Rust, основанные на KLEE, к коду Rust-for-Linux для проверки на наличие ошибок. Цель проекта - дать представление о потенциальных проблемах и о том, что нужно сделать, чтобы другие могли использовать инструменты формальной верификации для проверки аналогичного кода.</p>
<p>В итоге, хотя Rust Klee еще не готов к использованию в производстве, он все же заслуживает внимания как классный инструмент, который может помочь сформировать ландшафт формальной верификации в экосистеме Rust.</p>
<h2 id="haybale">Haybale<a aria-hidden="true" tabindex="-1" href="#haybale"><span class="icon icon-link"></span></a></h2>
<p>Haybale - это также движок символьного исполнения, имеющий схожие с Rust Klee возможности, за исключением того, что Haybale полностью написан на Rust и основан на Rust LLVM IR под капотом.</p>
<p>Хотя он не пытается стать еще одним Rust Klee, он все же обладает схожими функциями. Как механизм символьного исполнения, он фокусируется на преобразовании всех переменных вашей программы в математические выражения и анализирует пути выполнения для обнаружения ошибок или уязвимостей.</p>
<p>Самое лучшее в Haybale - это то, что он тестирует ваш Rust-код как есть, без добавления дополнительного тестового кода. Конечно, даже если мы все согласны с тем, что написание тестов - это лучшее, что можно сделать, это все равно считается скучной и утомительной задачей.</p>
<p>Вот пример из документации, который проверяет, вернет ли функция <code>foo</code> на выходе ноль:</p>
<pre class="astro-code poimandres" style="background-color:#1b1e28;color:#a6accd; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="rust"><code><span class="line"><span style="color:#A6ACCD">match </span><span style="color:#ADD7FF">find_zero_of_function</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCD">"</span><span style="color:#5DE4C7">foo</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">, </span><span style="color:#91B4D5">&#x26;</span><span style="color:#E4F0FB">project</span><span style="color:#A6ACCD">, </span><span style="color:#91B4D5">Config::</span><span style="color:#ADD7FF">default</span><span style="color:#A6ACCD">(), </span><span style="color:#A6ACCDC0">None</span><span style="color:#A6ACCD">) {</span></span>
<span class="line"><span style="color:#A6ACCDC0">    Ok</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCDC0">None</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">=></span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#ADD7FF">        println!</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCD">"</span><span style="color:#5DE4C7">foo никогда не может вернуть 0</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">    }</span></span>
<span class="line"><span style="color:#A6ACCDC0">    Ok</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCDC0">Some</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">inputs</span><span style="color:#A6ACCD">)) </span><span style="color:#91B4D5">=></span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#ADD7FF">        println!</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCD">"</span><span style="color:#5DE4C7">Inputs for which foo returns 0: </span><span style="color:#A6ACCD">{</span><span style="color:#5DE4C7">:?</span><span style="color:#A6ACCD">}"</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">inputs</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">    }</span></span>
<span class="line"><span style="color:#A6ACCDC0">    Err</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">e</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">=></span><span style="color:#A6ACCD"> {</span></span>
<span class="line"><span style="color:#ADD7FF">        panic!</span><span style="color:#A6ACCD">(</span><span style="color:#A6ACCD">"{}"</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">e</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">    }</span></span>
<span class="line"><span style="color:#A6ACCD">}</span></span>
<span class="line"></span></code></pre>
<p>Haybale может рассуждать обо всем коде, находить ошибки и выдавать отчет, который поможет вам доказать, есть ли в вашем коде ошибки, а затем воспроизвести и исправить их. Хотя Haybale может отловить не все ошибки, он, скорее всего, обнаружит критические ошибки, которые могут привести к сбоям во время выполнения, и даст вам шанс исправить их.</p>
<p>Klee и Haybale имеют свои ограничения, как и любой другой инструмент автоматической проверки. Например, Klee может не найти ошибок в исполняемых файлах, использующих сложные абстракции.</p>
<p>Как уже говорилось, механизмы символьного исполнения работают, исследуя все возможные пути через код программы, чтобы найти входные данные или условия, которые могут привести к неожиданному поведению или ошибкам. Однако программа, использующая сложные абстракции, такие как сложные структуры данных или сложные шаблоны проектирования, может создавать множество возможных путей выполнения.</p>
<p>Эта сложность может перегрузить такие инструменты, как Klee или Haybale, и затруднить эффективный анализ всех возможных сценариев. В результате они могут сдаться в процессе работы. В этом случае лучше всего использовать ручные или традиционные методы тестирования для проверки этих участков кода.</p>
<p>Давайте рассмотрим пять инструментов проверки Rust, которые мы обсудили в этом руководстве, в следующем сравнительном обзоре:</p>
<p>Инструмент Популярность (звезды GitHub) Поддержка сообщества Лучше всего использовать для… Совместимость версий Готов ли инструмент к производству?</p>
<p>cargo-fuzz 1.3k Активен Поиск ошибок, вызванных неожиданными или неправильно сформированными входными данными Rust 1.45 и выше ✅</p>
<p>Kani 1.4k Активно Находит ошибки, вызванные логикой с непредвиденными последствиями, и другие проблемы, которые трудно или невозможно обнаружить другими методами тестирования Rust 1.60 и выше ✅</p>
<p>Proptest 1.4k Активное тестирование свойств функции с большим количеством допустимых и недопустимых входов для поиска ошибок Rust 1.47 и выше ✅</p>
<p>Rust Klee 3 Неактивен Проверка специфических свойств программ на Rust, таких как инварианты безопасности и функциональная корректность Rust 1.47 и выше ❌</p>
<p>Haybale 455 Не очень активно Тестирование поведения программы с использованием символьных значений, а не известных входных данных Rust 1.47 и выше Haybale все еще находится в разработке, но уже используется некоторыми проектами для проверки своего кода.</p>
<p>Помните, что инструменты для проверки Rust находятся на ранней стадии развития, и со временем их будет становиться все больше.</p>
<h2 id="заключение">Заключение<a aria-hidden="true" tabindex="-1" href="#заключение"><span class="icon icon-link"></span></a></h2>
<p>Инструменты автоматической верификации очень важны для обнаружения ошибок при разработке программного обеспечения, хотя, возможно, они еще не получили широкого распространения среди разработчиков. Эти инструменты могут помочь вам обнаружить ошибки, которые вы не смогли бы найти с помощью классических методов тестирования, и повысить надежность вашего кода.</p>
<p>Счастливого хакинга!</p> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=5 инструментов автоматической проверки для Rust и когда использовать каждый из них&url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh&title=5 инструментов автоматической проверки для Rust и когда использовать каждый из них&summary=Rust  популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию примен&source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/5-ynstrumentov-avtomatycheskoi-proverky-dlia-rust-y-kohda-yspolzovat-kazhd-i-yz-nykh&media=&description=Rust  популярный язык программирования благодаря тому, что в нем особое внимание уделяется безопасности и надежности, а также тому, что он по умолчанию примен" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <nav class="circular-pagination" aria-label="Circular Pagination" data-astro-cid-ihkjvfsn> <a href="/blog/5-osnovn-kh-sovetov-kotor-e-dolzhen-znat-kazhd-i-dlia-optymyzatsyy-proyzvodytelnosty-react" class="circular-pagination__link circular-pagination__link--prev" data-astro-cid-ihkjvfsn> 5 основных советов, которые должен знать каждый для оптимизации производительности React  </a> <a href="/blog/4-sposoba-vnesty-svoi-vklad-v-open-source-ne-napysav-ny-strochky-koda" class="circular-pagination__link circular-pagination__link--next" data-astro-cid-ihkjvfsn> 4 способа внести свой вклад в Open-Source, не написав ни строчки кода </a> </nav>  </div> </div> </article> <div class="container" data-astro-cid-axzg2cw6> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z1T5Wnr" prefix="r0" component-url="/_astro/YandexRelatedAds.D-6fTqBY.js" component-export="default" renderer-url="/_astro/client.Bd2Qst3j.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;YandexRelatedAds&quot;,&quot;value&quot;:true}" await-children=""><div id="yandex_rtb_C-A-2592503-2"></div><!--astro:end--></astro-island> </div> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><astro-island uid="Z1U3gfI" component-url="/_astro/CommentBlock.ChJFdf82.js" component-export="default" renderer-url="/_astro/client.44T8euMP.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;CommentBlock&quot;,&quot;value&quot;:true}"></astro-island>  <!-- <div class="blocks__container container">
			<CtaBlock id="cta" class=""
			/>
		</div> --> </div>    </main> <footer class="footer" data-astro-cid-dwelrhxs> <div class="footer__container container" data-astro-cid-dwelrhxs> <a href="/" class="logo font-medium lowercase transition-colors fluid:text-lg footer__logo dark:hover:text-light text-blue dark:text-white" aria-label="logo" data-astro-cid-ijoll5s5> <svg width="1.44em" height="1em" viewBox="0 0 5660 3931" class="icon" data-astro-cid-ijoll5s5 data-icon="logo-one">  <use xlink:href="#ai:local:logo-one"></use>  </svg>  </a> <small class="footer__copyright" data-astro-cid-dwelrhxs>все права защищены. © 2024</small> </div> </footer>  </body></html>