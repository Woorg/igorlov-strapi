<!DOCTYPE html><html lang="ru"> <head><title>Создание ролика для игры в кости с помощью Three.js и Cannon-es - Igor Gorlov</title><link rel="canonical" href="https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es"><meta name="description" content="В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия."><meta name="robots" content="index, follow"><!-- favicon --><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><!-- theme meta --><meta name="theme-name" content="igorlov.ru"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="generator" content="Astro v4.5.1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- responsive meta --><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><meta name="google-adsense-account" content="ca-pub-0634695143666394"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/_regular_.DbkvWnAm.css" />
<style>.breadcrumbs[data-astro-cid-vcbh62el]{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));border-radius:min(1.5rem,1.1625rem + .45vw);padding-left:min(2rem,1.2125rem + 1.05vw);padding-right:min(2rem,1.2125rem + 1.05vw);padding-top:1rem;padding-bottom:1rem}.breadcrumbs[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__list[data-astro-cid-vcbh62el]{display:flex;align-items:center;gap:.125rem}.breadcrumbs__link[data-astro-cid-vcbh62el]{border-radius:9999px;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover{--tw-bg-opacity: 1;background-color:#fce4e1;background-color:rgba(252,228,225,var(--tw-bg-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]{padding:.125rem .75rem}.breadcrumbs__link[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#6a6a6a;background-color:rgba(106,106,106,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#8a8a93;background-color:rgba(138,138,147,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}
</style>
<link rel="stylesheet" href="/_astro/_single_.BCoIA8H8.css" />
<style>.circular-pagination[data-astro-cid-ihkjvfsn]{display:flex;width:100%;flex-wrap:wrap;align-items:center;justify-content:center;overflow:hidden;border-top-width:1px;--tw-border-opacity: 1;border-color:#020202;border-color:rgba(2,2,2,var(--tw-border-opacity));margin-top:min(1.25rem,1.1375rem + .15vw)}.circular-pagination__link[data-astro-cid-ihkjvfsn]{width:100%;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));text-decoration-line:none}.circular-pagination__link[data-astro-cid-ihkjvfsn]:hover{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.circular-pagination__link[data-astro-cid-ihkjvfsn]{padding-left:min(1.5rem,1.1625rem + .45vw);padding-right:min(1.5rem,1.1625rem + .45vw);padding-top:.5rem;padding-bottom:.5rem}
.comments[data-v-533071ec]{margin:auto;margin-top:1.25rem;max-width:42rem;--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.comments:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame[data-v-533071ec]{width:100%;--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity))}
.theme-toggle[data-v-8d8d9c54]{width:1.25rem;height:1.25rem}
</style><script type="module" src="/_astro/hoisted.DYPnEDpO.js"></script><style>[data-astro-transition-scope="astro-vgmtzcrq-1"] { view-transition-name: blog-image-sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es; }</style></head> <body class="flex min-h-screen flex-col bg-gray-light pt-14 font-inter text-dark fluid:text-lg dark:bg-black dark:text-white"> <header class="header" data-astro-cid-rq644orq> <div class="header__container container" data-astro-cid-rq644orq> <a href="/" class="logo font-medium lowercase transition-colors fluid:text-lg header__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>Фул фронт дев</a>  <div class="nav header__nav" data-astro-cid-7wkmezxd> <button class="nav__open" title="Открыть меню" data-astro-cid-7wkmezxd> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> </button> <nav class="nav__container" data-astro-cid-7wkmezxd> <button class="nav__close" title="Закрыть меню" data-astro-cid-7wkmezxd> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> </button> <ul class="nav__list" data-astro-cid-7wkmezxd> <li class="nav__item" data-astro-cid-7wkmezxd> <a href="/projects" class="nav__link" data-astro-cid-7wkmezxd> Работы. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="/blog" class="nav__link nav__link--active" data-astro-cid-7wkmezxd> Блог. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="#cta" class="nav__link" data-astro-cid-7wkmezxd> Контакты. </a> </li> </ul> </nav> </div>   <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();;(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();</script><astro-island uid="IJ3dh" component-url="/_astro/ThemeToggle.kpN4JrWQ.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-rq644orq&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;ThemeToggle&quot;,&quot;value&quot;:true}"></astro-island> </div> </header>  <main id="main-content" class="main flex-1">  <div class="blocks"> <div class="blocks__container container"> <nav aria-label="Breadcrumbs" class="breadcrumbs" data-astro-cid-vcbh62el> <ol class="breadcrumbs__list" role="list" data-astro-cid-vcbh62el> <li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/" data-astro-cid-vcbh62el> Главная </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/blog" data-astro-cid-vcbh62el> Blog </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el>  </li> </ol> </nav>  </div> <div class="blocks__container container"> <!-- <TextAds class="fade-in-bottom fluid:my-2" style="--delay: .8s;" /> --><article class="article" data-astro-cid-axzg2cw6> <div class="article__header" data-astro-cid-axzg2cw6> <ul class="article__categories categories" data-astro-cid-axzg2cw6> <li class="categories__item" data-astro-cid-axzg2cw6> <a href="/category/учебник" class="categories__link" data-astro-cid-axzg2cw6> Учебник  </a> </li> </ul> <h1 class="article__title text-wrap" data-astro-cid-axzg2cw6> Создание ролика для игры в кости с помощью Three.js и Cannon-es </h1> <ul class="article__tags tags" data-astro-cid-axzg2cw6> <li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/3d" data-astro-cid-axzg2cw6> 3d </a> </li><li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/cannon-es" data-astro-cid-axzg2cw6> Cannon-es </a> </li><li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/threejs" data-astro-cid-axzg2cw6> Three.js </a> </li><li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/webgl" data-astro-cid-axzg2cw6> Webgl </a> </li> </ul> <time class="article__date" data-astro-cid-axzg2cw6>
Опубликовано 29 янв., 2023 by  </time> <time class="article__date" data-astro-cid-axzg2cw6> Последнее изменение: 21 мар., 2024 </time> </div>  <figure class="article__image" data-astro-cid-axzg2cw6> <picture> <source srcset="/_astro/undefined-Jan-29-2023.CHhA-Fd4_18Q1Ej.avif" type="image/avif"><source srcset="/_astro/undefined-Jan-29-2023.CHhA-Fd4_Z19yK7w.webp" type="image/webp"> <img src="/_astro/undefined-Jan-29-2023.CHhA-Fd4_ZTSJrR.png" alt="Создание ролика для игры в кости с помощью Three.js и Cannon-es" class="aspect-auto h-full w-full object-cover object-center" loading="eager" data-astro-cid-axzg2cw6 data-astro-transition-scope="astro-vgmtzcrq-1" width="1200" height="500" decoding="async"> </picture> </figure>  <div class="article__content prose prose-zinc max-w-full break-words dark:prose-invert prose-p:text-balance prose-a:no-underline hover:prose-a:underline prose-figure:-mx-12 prose-figure:w-screen prose-figure:bg-gray-light prose-figure:p-10 prose-figcaption:text-dark dark:prose-figure:bg-dark dark:prose-figcaption:text-white" data-astro-cid-axzg2cw6> <div id="adfox_17062261612859555"></div> <script>(function(){const blockId = "adfox_17062261612859555";

	window.yaContextCb = window.yaContextCb || [];
	window.yaContextCb.push(() => {
		Ya.adfoxCode.createAdaptive(
			{
				ownerId: 1493338,
				containerId: blockId,
				params: {
					p1: 'dawgg',
					p2: 'p',
				},
			},
			['desktop', 'tablet', 'phone'],
			{
				tabletWidth: 830,
				phoneWidth: 480,
				isAutoReloads: true,
			},
		);
	});
})();</script> <div class="article__meta" data-astro-cid-axzg2cw6> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=Создание ролика для игры в кости с помощью Three.js и Cannon-es&#38;url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es&#38;title=Создание ролика для игры в кости с помощью Three.js и Cannon-es&#38;summary=В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия.&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es&#38;media=&#38;description=В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия." target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <a class="article__meta-section" href="#comments" data-astro-cid-axzg2cw6> Комментарии</a> </div> <!-- wp:image {"linkDestination":"custom"} -->
<figure class="wp-block-image"><a href="http://tympanus.net/Tutorials/DiceRoller/"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/diceroller-1.jpg" alt=""></a></figure>
<!-- /wp:image -->
<p>В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия. Мы начнем с создания кубиков с помощью модифицированной BoxGeometry без использования текстур, шейдеров или внешних 3D-моделей. Затем мы будем использовать cannon-es для включения физики, имитации броска кости и определения стороны приземления.</p>
<!-- wp:rank-math/toc-block {"title":"Оглавление","headings":[{"key":"845bdb06-a7bd-4b76-bafe-5136247a846b","content":"Кодирование кубиков","level":2,"link":"#кодирование-кубиков","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"166b2477-9877-484a-8a31-361f9588708e","content":"Закругление краев коробки","level":3,"link":"#закругление-краев-коробки","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"d3ffeff4-e66a-4ad8-a9e3-cdfbda6fd8b8","content":"Обновление нормалей","level":3,"link":"#обновление-нормалей","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"d976d3db-1f9f-459a-9639-6130bc2e7247","content":"Нанесение насечек по бокам","level":3,"link":"#нанесение-насечек-по-бокам","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"cbfebd21-8b68-4950-8cf7-ea05606ee9d0","content":"Нанесение цвета","level":3,"link":"#нанесение-цвета","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"4d07cb4f-5785-49aa-a883-ab5de7c1bcdb","content":"Выбор инструмента анимации","level":2,"link":"#выбор-инструмента-анимации","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"f1912078-0103-4bd6-b505-4ac435d66023","content":"Three.js сцена и физический мир","level":2,"link":"#three-js-сцена-и-физический-мир","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"0c9248b6-c1f8-43d3-9fa0-f23ac9748adc","content":"Анимирование кубиков","level":2,"link":"#анимирование-кубиков","disable":false,"isUpdated":false,"isGeneratedLink":true},{"key":"074cee85-a714-4e15-a4e1-0473c7c9116e","content":"Проверка верхней стороны","level":2,"link":"#проверка-верхней-стороны","disable":false,"isUpdated":false,"isGeneratedLink":true}],"listStyle":"ul"} -->
<div class="wp-block-rank-math-toc-block" id="rank-math-toc"><h2>Оглавление</h2><nav><ul><li class=""><a href="#кодирование-кубиков">Кодирование кубиков</a><ul><li class=""><a href="#закругление-краев-коробки">Закругление краев коробки</a></li><li class=""><a href="#обновление-нормалей">Обновление нормалей</a></li><li class=""><a href="#нанесение-насечек-по-бокам">Нанесение насечек по бокам</a></li><li class=""><a href="#нанесение-цвета">Нанесение цвета</a></li></ul></li><li class=""><a href="#выбор-инструмента-анимации">Выбор инструмента анимации</a></li><li class=""><a href="#three-js-сцена-и-физический-мир">Three.js сцена и физический мир</a></li><li class=""><a href="#анимирование-кубиков">Анимирование кубиков</a></li><li class=""><a href="#проверка-верхней-стороны">Проверка верхней стороны</a></li></ul></nav></div>
<!-- /wp:rank-math/toc-block -->
<h2 class="wp-block-heading" id="кодирование-кубиков">Кодирование кубиков</h2>
<p>Конечно, можно найти готовую модель кубика в интернете или создать ее в Blender, но давайте сделаем ее программно с помощью Three.js. В конце концов, мы же здесь учимся 🙂 .</p>
<p>Геометрия кубика будет основана на THREE.BoxGeometry, но изменена, чтобы скруглить углы коробки и добавить выемки на гранях.</p>
<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="закругление-краев-коробки">Закругление краев коробки</h3>
<p>Скругление углов коробки - довольно распространенная задача, поэтому для нее существует множество решений. Одно из таких решений включено в пакет Three.js: RoundedBoxGeometry расширяет класс BoxGeometry и может быть найден в папке examples/jsm/geometries/.</p>
<p>Класс RoundedBoxGeometry работает для любого размера коробки и предоставляет настраиваемую геометрию с включенным UV и нормалями. Если вам не нужны дополнительные модификации геометрии, RoundedBoxGeometry, скорее всего, будет идеальным решением ”из коробки” (ba dum tss!).</p>
<p>RoundedBoxGeometry позволяет задать количество сегментов для закругленной области, но плоские поверхности всегда строятся с одной парой треугольников.</p>
<!-- wp:image {"id":69639} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-provided-1-400x240.png" alt="" class="wp-image-69639"><figcaption class="wp-element-caption"><code>RoundedBoxGeometry</code></figcaption></figure>
<!-- /wp:image -->
<p>Из-за этого ограничения мы не можем добавить выемки на стороны коробки, поэтому мы создаем собственное решение для скругления граней.</p>
<p>За основу мы берем куб как BoxGeometry с приличным количеством сегментов.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const params = {
    segments: 50,
    edgeRadius: .07
};

let boxGeometry = new THREE.BoxGeometry(1, 1, 1, params.segments, params.segments, params.segments);</code></pre>
<!-- /wp:code -->
<!-- wp:image {"id":69584} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-1-400x210.png" alt="" class="wp-image-69584"><figcaption class="wp-element-caption">BoxGeometry</figcaption></figure>
<!-- /wp:image -->
<p>Практически, изменение геометрии означает перебор вершин бокса для доступа к координатам XYZ в массиве boxGeometry.attributes.position. После изменения координат XYZ они могут быть повторно применены к атрибуту position.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function createDiceGeometry() {
    let boxGeometry = new THREE.BoxGeometry(1, 1, 1, params.segments, params.segments, params.segments);
    const positionAttribute = boxGeometry.attributes.position;

    for (let i = 0; i &#x3C; positionAttribute.count; i++) {

        let position = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);

        // modify position.x, position.y and position.z

        positionAttribute.setXYZ(i, position.x, position.y, position.z);
    }

    return boxGeometry;
}</code></pre>
<!-- /wp:code -->
<p>Обратите внимание, что мы не кодируем универсальное решение, как RoundedBoxGeometry. Поскольку мы создаем кубическую форму, мы охватываем только случай, когда все стороны коробки равны 1. Мы также не утруждаем себя вычислением UV-координат, поскольку на кубик не нужно накладывать текстуру.</p>
<p>Начнем с выбора координат (положений вершин), которые находятся близко к граням коробки. Поскольку сторона коробки равна 1, мы знаем, что координаты X, Y и Z изменяются от -0,5 до 0,5.</p>
<p>Если все три координаты вершин близки к -0,5 или 0,5, то вершина геометрии близка к вершине коробки (постараемся не путать вершины геометрии, которые мы изменяем, с восемью вершинами коробки, которые мы округляем).</p>
<!-- wp:image {"id":69585} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-2-400x239.png" alt="" class="wp-image-69585"><figcaption class="wp-element-caption">all x, y, and z are close to 0.5 or -0.5</figcaption></figure>
<!-- /wp:image -->
<p>Если только 2 из 3 координат близки к -0,5 или 0,5, геометрическая вершина находится близко к краю коробки. Другие вершины сохраняют исходное положение. Например, если координаты X и Y близки к -0,5 или 0,5, вершина находится близко к краю, параллельному оси Z.</p>
<!-- wp:image {"id":69586} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-3-400x239.png" alt="" class="wp-image-69586"><figcaption class="wp-element-caption">only x and y are close to 0.5 or -0.5</figcaption></figure>
<!-- /wp:image -->
<p>Таким образом, мы выбираем все вершины геометрии, которые должны быть изменены:</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function createDiceGeometry() {
    // ...

    const subCubeHalfSize = .5 - params.edgeRadius;

    for (let i = 0; i &#x3C; positionAttribute.count; i++) {

        // ...

        if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.y) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
            // position is close to box vertex
        } else if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.y) > subCubeHalfSize) {
            // position is close to box edge that's parallel to Z axis
        } else if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
            // position is close to box edge that's parallel to Y axis
        } else if (Math.abs(position.y) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
            // position is close to box edge that's parallel to X axis
        }

        // ...
    }

    // ...
}</code></pre>
<!-- /wp:code -->
<p>Сначала давайте округлим вершины геометрии, которые находятся рядом с вершинами коробки. Мы хотим заменить их исходное положение координатой XYZ, лежащей на сфере, расположенной в углу коробки.</p>
<!-- wp:image {"id":69587} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-4-400x214.png" alt="" class="wp-image-69587"></figure>
<!-- /wp:image -->
<p>Чтобы преобразовать вектор положения таким образом, мы разбиваем его на две составляющие:</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><code>subCube - вектор, указывающий на бокс, радиус которого меньше исходного путем округления.</code></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>дополнение - остаток вектора положения</code></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">for (let i = 0; i &#x3C; positionAttribute.count; i++) {

    const subCubeHalfSize = .5 - params.edgeRadius;
    
    // ...

    const subCube = new THREE.Vector3(
        Math.sign(position.x),
        Math.sign(position.y),
        Math.sign(position.z)
    ).multiplyScalar(subCubeHalfSize);

    const addition = new THREE.Vector3().subVectors(position, subCubeEdges);

    // ...
}</code></pre>
<!-- /wp:code -->
<!-- wp:image {"id":69588} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-5-400x214.png" alt="" class="wp-image-69588"><figcaption class="wp-element-caption">subCube vector in purple, addition vector in black</figcaption></figure>
<!-- /wp:image -->
<p>Исходное положение вершины представляет собой сумму векторов subCube и addition. Мы оставляем subCube без изменений, так как он указывает на центр сферы. Вектор сложения мы нормализуем, чтобы он указывал на сферу с радиусом = 1</p>
<!-- wp:image {"id":69589} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-6-400x298.png" alt="" class="wp-image-69589"><figcaption class="wp-element-caption">subCube vector in purple, addition vector in black</figcaption></figure>
<!-- /wp:image -->
<p>… и умножить его на значение радиуса округления, чтобы переместить координату на нужную сферу.</p>
<!-- wp:image {"id":69590} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-7-400x218.png" alt="" class="wp-image-69590"><figcaption class="wp-element-caption">subCube vector in purple, addition vector in black</figcaption></figure>
<!-- /wp:image -->
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">for (let i = 0; i &#x3C; positionAttribute.count; i++) {

    // ...

    const subCube = new THREE.Vector3(Math.sign(position.x), Math.sign(position.y), Math.sign(position.z)).multiplyScalar(subCubeHalfSize);
    const addition = new THREE.Vector3().subVectors(position, subCube);

    if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.y) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
        // position is close to box vertex
        addition.normalize().multiplyScalar(params.edgeRadius);
        position = subCube.add(addition);
    }
    
    // ...
}</code></pre>
<!-- /wp:code -->
<p>С помощью приведенного выше кода мы можем обогнуть все вершины куба.</p>
<!-- wp:image {"id":69591} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-8-400x218.png" alt="" class="wp-image-69591"></figure>
<!-- /wp:image -->
<p>Тот же подход работает для краев коробки. Например, возьмем вершины геометрии, которые находятся рядом с краями бокса параллельно оси Z. Их position.z уже правильная, поэтому нужно изменить только координаты X и Y. Другими словами,</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><code>position.z не изменяется</code></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>addition.z должен быть установлен в ноль перед нормализацией вектора сложения</code></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<!-- wp:image {"id":69592} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-9-400x218.png" alt="" class="wp-image-69592"><figcaption class="wp-element-caption">subCube vector in purple, addition vector in black</figcaption></figure>
<!-- /wp:image -->
<p>Повторив это для других осей, мы получим геометрию округлого куба.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">let position = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);

const subCube = new THREE.Vector3(Math.sign(position.x), Math.sign(position.y), Math.sign(position.z)).multiplyScalar(subCubeHalfSize);
const addition = new THREE.Vector3().subVectors(position, subCube);

if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.y) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
    addition.normalize().multiplyScalar(params.edgeRadius);
    position = subCube.add(addition);
} else if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.y) > subCubeHalfSize) {
    addition.z = 0;
    addition.normalize().multiplyScalar(params.edgeRadius);
    position.x = subCube.x + addition.x;
    position.y = subCube.y + addition.y;
} else if (Math.abs(position.x) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
    addition.y = 0;
    addition.normalize().multiplyScalar(params.edgeRadius);
    position.x = subCube.x + addition.x;
    position.z = subCube.z + addition.z;
} else if (Math.abs(position.y) > subCubeHalfSize &#x26;&#x26; Math.abs(position.z) > subCubeHalfSize) {
    addition.x = 0;
    addition.normalize().multiplyScalar(params.edgeRadius);
    position.y = subCube.y + addition.y;
    position.z = subCube.z + addition.z;
}</code></pre>
<!-- /wp:code -->
<!-- wp:image {"id":69593} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/rounded-box-10-400x218.png" alt="" class="wp-image-69593"><figcaption class="wp-element-caption">vertices of rounded box</figcaption></figure>
<!-- /wp:image -->
<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="обновление-нормалей">Обновление нормалей</h3>
<p>Часто для обновления нормалей достаточно просто вызвать computeVertexNormals() после модификации вершин геометрии. Метод вычисляет нормаль для каждой вершины путем усреднения нормалей соседних граней (граней, которые разделяют эту вершину). Это очень простой способ сгладить геометрию, если только геометрия не имеет дублирующихся вершин.</p>
<p>Обычно 1+ вершин геометрии располагаются на одной и той же позиции, в основном для поддержания UV и нормальных атрибутов. Например, возьмем THREE.CylinderGeometry. Боковая поверхность имеет шов, который виден на левом рисунке. Есть два набора вершин, расположенных на этой вертикальной линии шва. Дублированные вершины имеют одинаковое положение и одинаковую нормаль, но разные UV-атрибуты. Первый набор вершин связан с гранями слева от линии шва (UV.x = 1), а второй набор вершин связан с гранями справа от шва (UV.x = 0). Дублирование вершин необходимо для правильного обертывания текстуры вокруг стороны и, в случае цилиндра, для поддержки параметраtaLength.<br>Конечно, THREE.CylinderGeometry идет с правильно рассчитанными нормалями, как вы видите на центральной картинке.</p>
<!-- wp:image {"id":69630} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/3xcylinder-800x267.png" alt="" class="wp-image-69630"><figcaption class="wp-element-caption"><code>CylinderGeometry</code> with texture (left), original normals (center), automatically recalculated normals (right)</figcaption></figure>
<!-- /wp:image -->
<p>Но если мы вызовем cylinder.geometry.computeVertexNormals() (даже без изменения геометрии), нормали станут такими, как показано на правом рисунке. Средние нормали граней отличаются для левого и правого набора дублированных вершин.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const material = new THREE.MeshNormalMaterial({});
const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 9), material);
// here normals are correct (central pic)

cylinder.geometry.computeVertexNormals();
// here normals have a seam (right pic)</code></pre>
<!-- /wp:code -->
<p>THREE.BoxGeometry также имеет дублированные вершины на коробке. Они расположены на гранях коробки. Вот почему мы можем легко наложить текстуры на каждую сторону коробки… и вот почему у нас возникает аналогичная проблема со швами.</p>
<p>На рисунке ниже показаны исходные нормали бокса на измененной геометрии</p>
<!-- wp:image {"id":69919} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/wireframes-and-original-nirmals-400x190.png" alt="" class="wp-image-69919"></figure>
<!-- /wp:image -->
<p>При наличии дополнительных вершин на гранях коробки функция computeVertexNormals() не дает правильного результата.</p>
<!-- wp:image {"id":69920} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/cube-normals-ill-3-315x300.png" alt="" class="wp-image-69920"></figure>
<!-- /wp:image -->
<p>Чтобы исправить швы, необходимо удалить все дублирующиеся вершины перед вызовом computeVertexNormals(). Это можно легко сделать с помощью метода mergeVertices(), который предназначен для удаления вершин с одинаковым набором атрибутов. Дублированные вершины имеют атрибуты normal и uv, унаследованные от BoxGeometry, которые мы удаляем. После этого у дублированных вершин остается только атрибут position, и вершины с одинаковой позицией могут быть автоматически объединены.</p>
<!-- wp:image {"id":69921} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/cube-normals-ill-4-315x300.png" alt="" class="wp-image-69921"></figure>
<!-- /wp:image -->
<p>P.S. Чтобы исправить нормали округлого куба, можно также просто повторно использовать вектор сложения вместо слияния вершин и повторного вычисления нормалей:</p>
<!-- wp:code -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript">const normalAttribute = boxGeometry.attributes.normal;
// ...
normalAttribute.setXYZ(i, addition.x, addition.y, addition.z);</code></pre>
<!-- /wp:code -->
<p>Это простое и элегантное решение, но мы хотим автоматически обновлять нормали после следующего изменения геометрии. Поэтому в сегодняшнем проекте мы используем комбинацию mergeVertices() и computeVertexNormals().</p>
<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="нанесение-насечек-по-бокам">Нанесение насечек по бокам</h3>
<p>Следующим шагом будет добавление от одного до шести гладких углублений на стороны куба. Для начала добавим одну в центр верхней стороны. Мы можем выбрать вершины верхней стороны, просто проверив, равно ли значение position.y 0,5. Для выбранных вершин мы уменьшим position.y на высоту выемки.</p>
<p>Сложность заключается в расчете формы выемки. Давайте сначала подумаем о двумерном пространстве и сформируем центрированный симметричный гладкий импульс по координатам XY.</p>
<p>Первый шаг - функция косинуса для волны с пиком в точке x = 0.</p>
<!-- wp:image {"id":69711} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/graph-1-1-400x226.png" alt="" class="wp-image-69711"></figure>
<!-- /wp:image -->
<p>Затем превратите его в положительное число, прибавив к Y 1.</p>
<!-- wp:image {"id":69712} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/graph-4-1-400x226.png" alt="" class="wp-image-69712"></figure>
<!-- /wp:image -->
<p>Период косинуса равен 2 x π, то есть центральная волна начинается в точке x = -π и заканчивается в точке x = π. Удобнее было бы иметь его от -1 до 1, поэтому мы умножаем x на π.</p>
<!-- wp:image {"id":69713} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/graph-3-1-400x226.png" alt="" class="wp-image-69713"></figure>
<!-- /wp:image -->
<p>Поскольку нам нужна только одна волна в центре, мы ограничиваем значение x от -1 до 1.</p>
<!-- wp:image {"id":69714} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/graph-2-1-400x226.png" alt="" class="wp-image-69714"></figure>
<!-- /wp:image -->
<p>Отлично! Импульс может быть параметризован переменными PULSE_WIDTH и PULSE_DEPTH, и именно так мы используем его для выемки кубика.</p>
<!-- wp:embed {"url":"https://codepen.io/ksenia-k/pen/VwBMNQN","type":"wp-embed","providerNameSlug":"codepen","align":"full"} -->
<figure class="wp-block-embed alignfull is-type-wp-embed is-provider-codepen wp-block-embed-codepen"><div class="wp-block-embed__wrapper">
https://codepen.io/ksenia-k/pen/VwBMNQN
</div></figure>
<!-- /wp:embed -->
<p>Преобразовать форму в трехмерное пространство довольно просто. Двумерная волна определяет Y как функцию X. Чтобы сделать Y функцией и X, и Z, мы просто перемножим две волны - первую, взятую как функцию X, и вторую, как функцию Z.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const notchWave = (v) => {
    v = (1 / params.notchRadius) * v;
    v = Math.PI * Math.max(-1, Math.min(1, v));
    return params.notchDepth * (Math.cos(v) + 1.);
}
const notch = (pos) => notchWave(pos[0]) * notchWave(pos[1]);</code></pre>
<!-- /wp:code -->
<p>Итак, для верхней стороны мы вычитаем значение notch([position.x, position.z]) из position.y, и аналогично для других сторон коробки. Поскольку наш импульс центрирован в точке (0, 0), мы можем сместить надсечки по боковой поверхности, добавив смещение к аргументам функции notch.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const offset = .23;

if (position.y === .5) {
    position.y -= notch([position.x, position.z]);
} else if (position.x === .5) {
    position.x -= notch([position.y + offset, position.z + offset]);
    position.x -= notch([position.y - offset, position.z - offset]);
} else if (position.z === .5) {
    position.z -= notch([position.x - offset, position.y + offset]);
    position.z -= notch([position.x, position.y]);
    position.z -= notch([position.x + offset, position.y - offset]);
} else if (position.z === -.5) {
    position.z += notch([position.x + offset, position.y + offset]);
    position.z += notch([position.x + offset, position.y - offset]);
    position.z += notch([position.x - offset, position.y + offset]);
    position.z += notch([position.x - offset, position.y - offset]);
} else if (position.x === -.5) {
    position.x += notch([position.y + offset, position.z + offset]);
    position.x += notch([position.y + offset, position.z - offset]);
    position.x += notch([position.y, position.z]);
    position.x += notch([position.y - offset, position.z + offset]);
    position.x += notch([position.y - offset, position.z - offset]);
} else if (position.y === -.5) {
    position.y += notch([position.x + offset, position.z + offset]);
    position.y += notch([position.x + offset, position.z]);
    position.y += notch([position.x + offset, position.z - offset]);
    position.y += notch([position.x - offset, position.z + offset]);
    position.y += notch([position.x - offset, position.z]);
    position.y += notch([position.x - offset, position.z - offset]);
}</code></pre>
<!-- /wp:code -->
<p>Мы вставляем этот код после первого изменения geometryBase.attributes.position и получаем готовую сетку кубиков.</p>
<!-- wp:image {"id":69633} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/final-dice-mesh-1-306x300.png" alt="" class="wp-image-69633"></figure>
<!-- /wp:image -->
<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="нанесение-цвета">Нанесение цвета</h3>
<p>Чтобы окрасить кубик, мы просто применим к нему серый материал MeshStandardMaterial.</p>
<!-- wp:image {"id":69634} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/final-dice-mesh-3-306x300.png" alt="" class="wp-image-69634"></figure>
<!-- /wp:image -->
<p>Чтобы раскрасить выемки, мы можем сделать простой трюк и разместить шесть плоскостей внутри куба так, чтобы они выходили из выемок.</p>
<!-- wp:image {"id":69637} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/final-dice-mesh-2-306x300.png" alt="" class="wp-image-69637"></figure>
<!-- /wp:image -->
<p>Мы завершаем работу над кубиками, окрашивая внутренние панели в черный цвет и группируя их с основной сеткой.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function createBoxGeometry() {
    let boxGeometry = new THREE.BoxGeometry(1, 1, 1, params.segments, params.segments, params.segments);

    // ...
    // modify boxGeometry.attributes.position and re-calculate normals

    return boxGeometry;
}

function createInnerGeometry() {
    
    // keep the plane size equal to flat surface of cube
    const baseGeometry = new THREE.PlaneGeometry(1 - 2 * params.edgeRadius, 1 - 2 * params.edgeRadius);
    
    // place planes a bit behind the box sides
    const offset = .48;

    // and merge them as we already have BufferGeometryUtils file loaded :)
    return BufferGeometryUtils.mergeBufferGeometries([
        baseGeometry.clone().translate(0, 0, offset),
        baseGeometry.clone().translate(0, 0, -offset),
        baseGeometry.clone().rotateX(.5 * Math.PI).translate(0, -offset, 0),
        baseGeometry.clone().rotateX(.5 * Math.PI).translate(0, offset, 0),
        baseGeometry.clone().rotateY(.5 * Math.PI).translate(-offset, 0, 0),
        baseGeometry.clone().rotateY(.5 * Math.PI).translate(offset, 0, 0),
    ], false);
}

function createDiceMesh() {
    const boxMaterialOuter = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
    })
    const boxMaterialInner = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0,
        metalness: 1,
        side: THREE.DoubleSide
    })

    const diceMesh = new THREE.Group();
    const innerMesh = new THREE.Mesh(createInnerGeometry(), boxMaterialInner);
    const outerMesh = new THREE.Mesh(createBoxGeometry(), boxMaterialOuter);
    diceMesh.add(innerMesh, outerMesh);

    return diceMesh;
}</code></pre>
<!-- /wp:code -->
<!-- wp:embed {"url":"https://codepen.io/ksenia-k/pen/rNrYNgj","type":"wp-embed","providerNameSlug":"codepen","align":"full"} -->
<figure class="wp-block-embed alignfull is-type-wp-embed is-provider-codepen wp-block-embed-codepen"><div class="wp-block-embed__wrapper">
https://codepen.io/ksenia-k/pen/rNrYNgj
</div></figure>
<!-- /wp:embed -->
<p>Далее мы перейдем к анимации. Обратите внимание, что вторая часть этого урока не зависит от первой и наоборот.</p>
<h2 class="wp-block-heading" id="выбор-инструмента-анимации">Выбор инструмента анимации</h2>
<p>Цитируя любой учебник на эту тему, я должен сказать, что Three.js - это инструмент для рисования 3D-сцен в браузере. Он не включает в себя физический движок или другие встроенные инструменты для работы с анимацией. Чтобы избежать путаницы, система анимации Three.js - это API, который в основном используется для запуска анимации для импортированных моделей. Она не сильно помогает создавать новые переходы (за исключением KeyframeTrack, но он довольно прост).</p>
<p>Чтобы добавить движение и взаимодействие в сцену, нам нужно вычислить значения анимированных свойств для каждого кадра. Анимированным свойством может быть трансформация 3D-объекта, цвет материала или любой другой атрибут экземпляра Three.js.</p>
<p>Вычисление анимированного свойства может быть простым, как увеличение его значения в цикле requestAnimationFrame(), или сложным, как импорт какого-либо игрового движка для вычисления трансформаций.</p>
<p>Характер и сложность перехода определяют выбор инструмента анимации.</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>Для базовых условий, линейных переходов и простых смягчений, интерполяций и других тривиальных вычислений обходитесь без дополнительных либ.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Используйте GSAP для создания цепочки из нескольких анимаций, для обработки пользовательских смягчений, для разработки анимации с прокруткой и других относительно сложных переходов. Это добавит 60-80 кб к вашему приложению.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Если вам нужно применить силы к объектам и заставить их сталкиваться друг с другом, воспользуйтесь инструментами физики.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<p>Что касается физики, существует множество решений, совместимых с Three.js. В зависимости от проекта, это может быть 3D или только 2D физика, с поддержкой мягких тел или без нее и т.д. Некоторые библиотеки будут включать в себя определенные функции, например, моделирование транспортных средств или ткани. Некоторые лучше совместимы с React, некоторые имеют богатые инструменты отладки и т.д.</p>
<p>В этом учебнике у нас есть только кубики, падающие на поверхность. С точки зрения физики, наши требования таковы:</p>
<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li>Только жесткие тела (форма кубика не будет деформироваться, поэтому нам не нужна поддержка мягких тел)</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Формы объектов Box и Plane</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Обнаружение столкновений, чтобы кубики сталкивались друг с другом и с нижней плоскостью</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Силы, чтобы бросить кубики и позволить им упасть на пол</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->
<p>Технически, это все очень базовые требования, и любая библиотека 3D физики будет работать. Поэтому имеет смысл рассмотреть только:</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>минимальный размер</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>достойная поддержка (документация, примеры и т.д.)</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<p>Cannon-es хорошо подходит. Библиотека в минимальной комплектации добавит всего 40-50 кб к проекту. Это похоже на самый низкий уровень, который можно получить для 3D физики на данный момент. Иногда указывается, что Physijs имеет примерно такой же размер, но на самом деле Physijs - это плагин, который помогает использовать библиотеку ammo.js, поэтому вам всегда нужно загружать оба файла.</p>
<p>Поддержка cannon-es на данный момент в порядке - не так хорошо, как для Three.js или GSAP, но хорошо по сравнению с другими доступными вариантами физики.</p>
<p>Вы можете увидеть, что библиотека называется устаревшей, но это всего лишь путаница между Cannon.js и cannon-es. Первая - это оригинальный инструмент, который не обновлялся с 2016 года. На самом деле, он по-прежнему совместим с современным Three.js. Но что более важно, он был форкнут в 2020 году замечательной командой pmndrs и с тех пор регулярно обновляется как JS-модуль и как React-компонент.</p>
<p>Вы можете найти множество статей и примеров на эту тему. Старый контент все еще может быть очень полезен, хотя идеальной совместимости между различными версиями Cannon.js и cannon-es не существует.</p>
<h2 class="wp-block-heading" id="three-js-сцена-и-физический-мир">Three.js сцена и физический мир</h2>
<p>Основная идея заключается в построении трехмерного физического мира параллельно с трехмерной сценой. Мы добавляем в физический мир все 3D-объекты, которые должны двигаться и взаимодействовать как тела одинаковой формы. После применения физических свойств и сил к физическим телам, мы позволяем движку моделировать физический мир кадр за кадром. На каждом этапе симуляции мы берем трансформации, рассчитанные для физических тел, применяем их к видимым объектам и рендерим (перерисовываем) сцену Three.js.</p>
<p>Вот созданный объект physicsWorld. Чуть позже мы добавим к нему несколько свойств.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">let physicsWorld = new CANNON.World({})</code></pre>
<!-- /wp:code -->
<p>Я опускаю часть с созданием сцены Three.js, поскольку это всего лишь базовая установка с парой света и теней. И если вы дошли до этого момента, то, скорее всего, вы уже знакомы с Three.js 🙂 .</p>
<p>Чтобы создать пол, мы добавляем в сцену горизонтальную плоскость. Она не имеет цвета и только получает тени. Затем мы добавляем эту же плоскость в физический мир как статический объект. Она наследует положение и вращение сетки, и поскольку пол статичен, эти значения не будут меняться.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function createFloor() {
    
    // Three.js (visible) object
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.ShadowMaterial({
            opacity: .1
        })
    )
    floor.receiveShadow = true;
    floor.position.y = -7;
    floor.quaternion.setFromAxisAngle(new THREE.Vector3(-1, 0, 0), Math.PI * .5);
    scene.add(floor);

    // Cannon-es (physical) object
    const floorBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
    });
    floorBody.position.copy(floor.position);
    floorBody.quaternion.copy(floor.quaternion);
    physicsWorld.addBody(floorBody);
}</code></pre>
<!-- /wp:code -->
<p>Для создания кубиков мы используем функцию createDiceMesh(), описанную выше, без особых изменений. Для нескольких кубиков мы можем клонировать исходный объект для повышения производительности.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const diceArray = []; // to store { mesh, body } for a pair of visible mesh and physical body

diceMesh = createDiceMesh(); // returns dice as a THREE.Group()

for (let i = 0; i &#x3C; params.numberOfDice; i++) {
    diceArray.push(createDice());
}

function createDice() {
    const mesh = diceMesh.clone();
    scene.add(mesh);

    const body = new CANNON.Body({
        mass: 1,
        shape: new CANNON.Box(new CANNON.Vec3(.5, .5, .5)),
    });
    physicsWorld.addBody(body);

    return {mesh, body};
}</code></pre>
<!-- /wp:code -->
<p>Вы можете заметить, что сетка кубиков основана на THREE.BoxGeometry(1, 1, 1), в то время как CANNON.Box основан на size = 0.5. Так что да, cannon-es box принимает половину размера в качестве аргумента, в то время как Three.js принимает полный размер, и у меня нет объяснения этому ¯*(ツ)*/¯.  Вы можете поймать такие вещи с помощью cannon-es-debugger, который генерирует видимые wireframes для физических тел.</p>
<p>Как и пол, сетка кубиков должна иметь такое же положение и вращение, как и тело кубика. Но в отличие от пола, свойства кубиков анимированы. Поэтому мы заботимся о трансформации кубиков вне функции createDice().</p>
<h2 class="wp-block-heading" id="анимирование-кубиков">Анимирование кубиков</h2>
<p>Мы управляем анимацией кубиков с помощью двух функций:</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>throwDice(), где положение игральных костей сбрасывается до начальных значений. Функция будет вызываться в любое время пользователем, чтобы бросить игральную кость</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>render(), где рассчитывается следующий шаг физического мира, обновляется положение тела кости, и мы копируем его на видимую сетку. Функция выполняется в бесконечном цикле requestAnimationFrame()</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function render() {
    // recalculate the physics world
    physicsWorld.fixedStep();

    // apply recalculated values to visible elements 
    for (const dice of diceArray) {
        dice.mesh.position.copy(dice.body.position)
    }

    // redraw the scene
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

function throwDice() {
    diceArray.forEach((d, dIdx) => {
        d.body.position = new CANNON.Vec3(5, dIdx * 1.5, 0); // the floor is placed at y = -7
        d.mesh.position.copy(d.body.position);
    });
}</code></pre>
<!-- /wp:code -->
<p>Сейчас у нас есть кубики, висящие над полом. Они не двигаются, так как к ним еще не приложена сила.</p>
<!-- wp:image {"id":69723} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-01-800x504.png" alt="" class="wp-image-69723"></figure>
<!-- /wp:image -->
<p>Первая сила, которую мы добавляем, - это всемирное тяготение.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function initPhysics() {
    physicsWorld = new CANNON.World({
        gravity: new CANNON.Vec3(0, -50, 0),
    })
}</code></pre>
<!-- /wp:code -->
<p>Обычно гравитация задается как вертикальная сила со значением y = -9.8. Это относится к гравитации Земли (9,807 м/с²) и предполагает, что вы хотите сохранить физику в ”настоящих” единицах СИ: силы в м/с², массы в килограммах, расстояния в метрах и так далее. Это возможно, но гравитация 9.8 имеет смысл только в том случае, если вы сохраняете все остальные свойства мира, объектов и материалов физически корректными. Плюс, в этом случае .fixedStep() следует заменить на функцию .step(), чтобы изменить скорость симуляции на “реальные” секунды.</p>
<p>На практике использование значения гравитации Земли редко бывает необходимым, и добиться даже реалистичного движения можно, просто экспериментируя с различными комбинациями сил, скорости, вращения и массы. Гравитация - это сила, влияющая на все динамические тела. Она не обязана иметь определенное значение или быть направленной вниз.</p>
<p>Для кубиков мы используем вертикальную силу с y = 50. Она заставляет кубики падать на пол.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-02.webm"></video></figure>
<!-- /wp:video -->
<p>Чтобы сделать кубики более упругими, мы изучим понятия материала и контактного материала. Материал - это свойство каждого физического тела, а материал контакта - это пушечная сущность, описывающая взаимодействие пары материалов.</p>
<p>Поскольку все кубики являются одинаковыми физическими телами и в сцене нет других динамических объектов, достаточно использовать один материал и один контактный материал. Библиотека cannon-es предоставляет world.defaultMaterial и world.defaultContactMaterial, которые применяются автоматически. Поэтому нет необходимости создавать новые.</p>
<p>Параметры по умолчанию для материала контакта, включая трение и реституцию, уже определены в библиотеке. Хотя трение по умолчанию кажется достаточным, мы увеличим значение реституции с 0 до 0,3, чтобы добиться более упругого эффекта.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function initPhysics() {
    // ...
    physicsWorld.defaultContactMaterial.restitution = .3;
}</code></pre>
<!-- /wp:code -->
<p>Обновление значения реституции приводит к более живому и энергичному движению кубиков.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-03.webm"></video></figure>
<!-- /wp:video -->
<p>Добавление случайного начального вращения к каждой кости обеспечивает более естественное и непредсказуемое движение броска:</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function throwDice() {
    diceArray.forEach((d, dIdx) => {

        // to reset the velocity dice got on the previous throw
        d.body.velocity.setZero();
        d.body.angularVelocity.setZero();
        
        // set initial position
        // ...
        
        // set initial rotation
        d.mesh.rotation.set(2 * Math.PI * Math.random(), 0, 2 * Math.PI * Math.random())
        d.body.quaternion.copy(d.mesh.quaternion);
    });
}</code></pre>
<!-- /wp:code -->
<p>Поскольку вращение кубика, как и его положение, динамично, мы также обновляем кватернион кубика на каждом шаге моделирования.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function render() {
    // recalculate the physics world
    // ...
    
    // apply recalculated values to visible elements 
    for (const dice of diceArray) {
        dice.mesh.position.copy(dice.body.position);
        dice.mesh.quaternion.copy(dice.body.quaternion);
    }
    
    // redraw the scene
    // ...
}</code></pre>
<!-- /wp:code -->
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-04.webm"></video></figure>
<!-- /wp:video -->
<p>Сейчас кубики падают вниз под действием силы тяжести. Чтобы бросить их, нам нужно вскоре приложить дополнительную силу. Другими словами, приложить произвольный импульс, который заставит кубик лететь немного вверх и влево.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function throwDice() {
    diceArray.forEach((d, dIdx) => {
        // reset velocity, set initial position &#x26; rotation
        // ...
        
        const force = 3 + 5 * Math.random();
        d.body.applyImpulse(
            new CANNON.Vec3(-force, force, 0)
        );
    });
}</code></pre>
<!-- /wp:code -->
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-05.webm"></video></figure>
<!-- /wp:video -->
<p>Без второго аргумента сила applyImpulse() добавляется к центру масс кубика. Но если мы немного сместим его от точки по умолчанию (0, 0, 0), импульс придаст дополнительную угловую скорость и закрутит кубик.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">d.body.applyImpulse(
    new CANNON.Vec3(-force, force, 0),
    new CANNON.Vec3(0, 0, .2) // point of application of force is shifted from the center of mass 
);</code></pre>
<!-- /wp:code -->
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/physics-06.webm"></video></figure>
<!-- /wp:video -->
<p>Вот и все. Кубики бросаются случайно, но в то же время они приземляются в предсказуемой области.</p>
<h2 class="wp-block-heading" id="проверка-верхней-стороны">Проверка верхней стороны</h2>
<p>Последнее, что нужно сделать, это проверить верхнюю сторону каждого кубика после завершения броска. Помимо добавления таких элементов, как кнопка для броска костей и место для отображения счета, нам необходимо:</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>запечатлеть момент неподвижности для каждого броска игральных костей</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>проверьте окончательное вращение и получите число верхней стороны</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<p>В Cannon-es есть несколько удобных обратных вызовов, которые мы можем использовать здесь: sleepyEvent, sleepEvent и wakeupEvent. После установки опции allowSleep в true для мира физики мы можем получить доступ к этим событиям. Cannon-es отслеживает скорость движения тела и запускает события, связанные со сном, используя sleepSpeedLimit и sleepTimeLimit. Как только скорость становится меньше sleepSpeedLimit, мы получаем событие sleepy, а если состояние sleepy длится дольше sleepTimeLimit, то получаем событие sleep.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function initPhysics() {
    physicsWorld = new CANNON.World({
        allowSleep: true,
        // ...
    })
}

function initScene() {

    // ...

    for (let i = 0; i &#x3C; params.numberOfDice; i++) {
        diceArray.push(createDice());
        addDiceEvents(diceArray[i]);
    }

    // ...
}

function addDiceEvents(dice) {
    dice.body.addEventListener('sleep', (e) => {
        // ...
    });
}
</code></pre>
<!-- /wp:code -->
<p>Пределы настраиваются, и мы можем изменить sleepTimeLimit с 1 секунды по умолчанию на 0,1 секунды. Таким образом, у нас есть обратный вызов sleep при условии ”кубик имеет стабильное положение в течение 100 мс подряд”.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function createDice() {
    // ...
    
    const body = new CANNON.Body({
        // ...
        sleepTimeLimit: .1 // change from default 1 sec to 100ms
    });
    
    // ...
}</code></pre>
<!-- /wp:code -->
<p>Событие срабатывает, когда бросок кубика завершен. Скорее всего, это означает, что игральная кость лежит на полу или (редко и при большом количестве костей) она устойчиво встала на ребро. В первом случае мы отключаем отслеживание скорости для тела кубика и проверяем конечную ориентацию, чтобы считать счет. Если кубик балансирует на грани, мы сохраняем трекер сна включенным.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">function addDiceEvents(dice) {
    dice.body.addEventListener('sleep', (e) => {

        dice.body.allowSleep = false;

        // check the dice rotation
        
        if (lyingOnSide) {
            // show result
        } else {
            // landed on edge => wait to fall on side and fire the event again
            dice.body.allowSleep = true;
        }
    });
}

function throwDice() {
    diceArray.forEach((d, dIdx) => {
        // ...
        
        // track body velocity again for new throw
        d.body.allowSleep = true;
    });
}</code></pre>
<!-- /wp:code -->
<p>Чтобы проверить ориентацию кубика, а именно сторону, которая оказалась сверху, мы принимаем вращение за вектор Эйлера и анализируем эйлеровы компоненты.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const euler = new CANNON.Vec3();
dice.body.quaternion.toEuler(euler);</code></pre>
<!-- /wp:code -->
<p>Известно, что</p>
<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>игральная кость была создана таким образом, чтобы сторона №1 была на Yplus, сторона №6 на Yminus, сторона №2 на Xplus, сторона №5 на Xminus, сторона №3 на Zplus и сторона №4 на Zminus</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>поверхность пола перпендикулярна оси Y</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>кватернион преобразуется к эйлеровой системе координат в порядке YZX</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
<!-- wp:image {"id":69678} -->
<figure class="wp-block-image"><img src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/1-side-400x288.png" alt="" class="wp-image-69678"></figure>
<!-- /wp:image -->
<p>Вращение, хранящееся в векторе Эйлера, - это набор из трех вращений, которые выполняются в порядке YZX по отношению к локальной системе координат. Таким образом, первое вращение происходит вокруг локальной оси Y (которая совпадает с мировой осью Y), затем вокруг локальной оси Z (которая теперь может отличаться от мировой оси Z), затем локальное вращение X (которое может отличаться от мировой оси X).</p>
<p>Первое вращение по оси Y может быть абсолютно случайным, и кубик все равно будет лежать на полу стороной №1 вверх. Это означает, что нам не нужен euler.y для вычисления результата.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/y-random.webm"></video></figure>
<!-- /wp:video -->
<p>Очевидно, что euler.z и euler.x должны быть кратны π/2, поэтому мы можем перебрать возможные комбинации.</p>
<p>Как уже говорилось, при euler.z = 0 и euler.x = 0 мы получим сторону №1.</p>
<p>При euler.z = 0 вращение куба вокруг локальной оси X на π/2, -π/2 и на -π (-π здесь равно π) приводит к ориентации сторон #4, #3 и #6 соответственно.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/randY-x-options.webm"></video></figure>
<!-- /wp:video -->
<p>При euler.z = 0.5 куб поворачивается вокруг оси Z на π/2, и мы имеем сторону #2 на вершине независимо от поворота по оси X. Фактически, ось X теперь совпадает с исходной осью Y, поэтому мы получили блокировку Gimbal lock.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/randY-z-plus.webm"></video></figure>
<!-- /wp:video -->
<p>То же самое для случая поворота Z на -π/2. Ось X снова фиксируется, и мы всегда имеем сторону №5 сверху.</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/randY-z-minus.webm"></video></figure>
<!-- /wp:video -->
<p>Согласно определению угла Эйлера, второе вращение (Z-вращение с порядком YZX) охватывает только диапазон π (в то время как первое и третье вращения имеют диапазон 2 x π). Другими словами, Z-вращение определено только между -π/2 и π/2, так что все варианты углов кубика покрыты.</p>
<!-- wp:code {"lineNumbers":true} -->
<pre class="wp-block-code"><code lang="javascript" class="language-javascript line-numbers">const eps = .1;
let isZero = (angle) => Math.abs(angle) &#x3C; eps;
let isHalfPi = (angle) => Math.abs(angle - .5 * Math.PI) &#x3C; eps;
let isMinusHalfPi = (angle) => Math.abs(.5 * Math.PI + angle) &#x3C; eps;
let isPiOrMinusPi = (angle) => (Math.abs(Math.PI - angle) &#x3C; eps || Math.abs(Math.PI + angle) &#x3C; eps);

if (isZero(euler.z)) {
    if (isZero(euler.x)) {
        showRollResults(1);
    } else if (isHalfPi(euler.x)) {
        showRollResults(4);
    } else if (isMinusHalfPi(euler.x)) {
        showRollResults(3);
    } else if (isPiOrMinusPi(euler.x)) {
        showRollResults(6);
    } else {
        // landed on edge => wait to fall on side and fire the event again
        dice.body.allowSleep = true;
    }
} else if (isHalfPi(euler.z)) {
    showRollResults(2);
} else if (isMinusHalfPi(euler.z)) {
    showRollResults(5);
} else {
    // landed on edge => wait to fall on side and fire the event again
    dice.body.allowSleep = true;
}</code></pre>
<!-- /wp:code -->
<p>В этом учебнике мы рассмотрели использование Three.js и cannon-es для создания динамичного и интерактивного ролика для игры в кости. Манипулируя 3D-формами, экспериментируя с различными комбинациями сил и настраивая свойства физических тел, мы смогли создать реалистичную и увлекательную симуляцию. Элементы пользовательского интерфейса и дополнительный код для этого проекта можно найти в сопроводительном репозитории. Мы рекомендуем вам загрузить проект и поэкспериментировать с различными настройками и параметрами, чтобы углубить свое понимание и навыки в анимации и физическом моделировании. Получайте удовольствие!</p>
<!-- wp:video -->
<figure class="wp-block-video"><video controls src="https://i7x7p5b7.stackpathcdn.com/codrops/wp-content/uploads/2023/01/dice-final.mov"></video></figure>
<!-- /wp:video -->
<p>Check out the <a href="http://tympanus.net/Tutorials/DiceRoller/" target="_blank" rel="noreferrer noopener">final demo</a> and see the full code in the <a href="https://github.com/uuuulala/Threejs-rolling-dice-tutorial/" target="_blank" rel="noreferrer noopener">GitHub repo</a>. 🎲 🤘</p> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=Создание ролика для игры в кости с помощью Three.js и Cannon-es&#38;url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es&#38;title=Создание ролика для игры в кости с помощью Three.js и Cannon-es&#38;summary=В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия.&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/sozdanie-rolika-dlya-igry-v-kosti-s-pomoshhyu-three-js-i-cannon-es&#38;media=&#38;description=В этом руководстве мы проведем вас через процесс создания интерактивного 3D-ролика из игральных костей, используя библиотеки JavaScript Three.js для создания 3D-графики и cannon-es для добавления взаимодействия." target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <nav class="circular-pagination" aria-label="Circular Pagination" data-astro-cid-ihkjvfsn> <a href="/blog/sozdanie-sistemy-autentifikaczii-bez-parolya" class="circular-pagination__link circular-pagination__link--prev" data-astro-cid-ihkjvfsn> Создание системы аутентификации без пароля </a> <a href="/blog/sozdanie-kart-react-native-s-pomoshhyu-mapbox" class="circular-pagination__link circular-pagination__link--next" data-astro-cid-ihkjvfsn> Создание карт React Native с помощью Mapbox </a> </nav>  </div> </article> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><astro-island uid="Z1T5Wnr" prefix="r0" component-url="/_astro/YandexRelatedAds.svLg6TOn.js" component-export="default" renderer-url="/_astro/client.D9Vng9vH.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;YandexRelatedAds&quot;,&quot;value&quot;:true}" await-children=""><div id="yandex_rtb_C-A-2592503-2"></div><!--astro:end--></astro-island> <astro-island uid="Z2a8j9B" component-url="/_astro/CommentBlock.BwogX8bT.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;CommentBlock&quot;,&quot;value&quot;:true}"></astro-island>  </div> <!-- <div class="blocks__container container">
			<CtaBlock id="cta" class=""
			/>
		</div> --> </div>    </main> <footer class="footer" data-astro-cid-dwelrhxs> <div class="footer__container container" data-astro-cid-dwelrhxs> <a href="/" class="logo font-medium lowercase transition-colors fluid:text-lg footer__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>Фул фронт дев</a>  <small class="footer__copyright" data-astro-cid-dwelrhxs>все права защищены. © 2024</small> </div> </footer>  </body></html>