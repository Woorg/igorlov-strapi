<!DOCTYPE html><html lang="ru"> <head><title>10 лучших алгоритмов сортировки с примерами | Игорь Горлов - Фронтeндер</title><link rel="canonical" href="https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy"><meta name="description" content="Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая"><meta name="robots" content="index, follow"><!-- favicon --><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><!-- theme meta --><meta name="theme-name" content="igorlov.ru"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="generator" content="Astro v4.5.1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- responsive meta --><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><meta name="google-adsense-account" content="ca-pub-0634695143666394"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/_regular_.uIaUWrkB.css" />
<style>.breadcrumbs[data-astro-cid-vcbh62el]{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));border-radius:min(1.5rem,1.1625rem + .45vw);padding-left:min(2rem,1.2125rem + 1.05vw);padding-right:min(2rem,1.2125rem + 1.05vw);padding-top:1rem;padding-bottom:1rem}.breadcrumbs[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__list[data-astro-cid-vcbh62el]{display:flex;align-items:center;gap:.125rem}.breadcrumbs__link[data-astro-cid-vcbh62el]{border-radius:9999px;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover{--tw-bg-opacity: 1;background-color:#fce4e1;background-color:rgba(252,228,225,var(--tw-bg-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]{padding:.125rem .75rem}.breadcrumbs__link[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#6a6a6a;background-color:rgba(106,106,106,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#8a8a93;background-color:rgba(138,138,147,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}
</style>
<link rel="stylesheet" href="/_astro/_single_.CyWP_2Jq.css" />
<style>.circular-pagination[data-astro-cid-ihkjvfsn]{display:flex;width:100%;flex-wrap:wrap;align-items:center;justify-content:center;overflow:hidden;border-top-width:1px;--tw-border-opacity: 1;border-color:#020202;border-color:rgba(2,2,2,var(--tw-border-opacity));margin-top:min(1.25rem,1.1375rem + .15vw)}.circular-pagination__link[data-astro-cid-ihkjvfsn]{width:100%;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));text-decoration-line:none}.circular-pagination__link[data-astro-cid-ihkjvfsn]:hover{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.circular-pagination__link[data-astro-cid-ihkjvfsn]{padding-left:min(1.5rem,1.1625rem + .45vw);padding-right:min(1.5rem,1.1625rem + .45vw);padding-top:.5rem;padding-bottom:.5rem}
.comments[data-v-533071ec]{margin:auto;margin-top:1.25rem;max-width:42rem;--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.comments:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame[data-v-533071ec]{width:100%;--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity))}
.theme-toggle[data-v-8d8d9c54]{width:1.25rem;height:1.25rem}
</style><script type="module" src="/_astro/hoisted.DYPnEDpO.js"></script><style>[data-astro-transition-scope="astro-vgmtzcrq-1"] { view-transition-name: blog-image-10-luchshykh-alhorytmov-sortyrovky-s-prymeramy; }</style></head> <body class="flex min-h-screen flex-col bg-gray-light pt-14 font-inter text-dark fluid:text-lg dark:bg-black dark:text-white"> <header class="header" data-astro-cid-rq644orq> <div class="header__container container" data-astro-cid-rq644orq> <a href="/" class="logo font-extrabold lowercase transition-colors fluid:text-lg header__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>Фул фронт дев</a>  <div class="nav header__nav" data-astro-cid-7wkmezxd> <button class="nav__open" title="Открыть меню" data-astro-cid-7wkmezxd> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> </button> <nav class="nav__container" data-astro-cid-7wkmezxd> <button class="nav__close" title="Закрыть меню" data-astro-cid-7wkmezxd> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> </button> <ul class="nav__list" data-astro-cid-7wkmezxd> <li class="nav__item" data-astro-cid-7wkmezxd> <a href="/projects" class="nav__link" data-astro-cid-7wkmezxd> Работы. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="/blog" class="nav__link nav__link--active" data-astro-cid-7wkmezxd> Блог. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="#cta" class="nav__link" data-astro-cid-7wkmezxd> Контакты. </a> </li> </ul> </nav> </div>   <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();;(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();</script><astro-island uid="IJ3dh" component-url="/_astro/ThemeToggle.kpN4JrWQ.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-rq644orq&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;ThemeToggle&quot;,&quot;value&quot;:true}"></astro-island> </div> </header>  <main id="main-content" class="main flex-1">  <div class="blocks"> <div class="blocks__container container"> <nav aria-label="Breadcrumbs" class="breadcrumbs" data-astro-cid-vcbh62el> <ol class="breadcrumbs__list" role="list" data-astro-cid-vcbh62el> <li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/" data-astro-cid-vcbh62el> Главная </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/blog" data-astro-cid-vcbh62el> Blog </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el>  </li> </ol> </nav>  </div> <div class="blocks__container container"> <!-- <TextAds class="fade-in-bottom fluid:my-2" style="--delay: .8s;" /> --><article class="article" data-astro-cid-axzg2cw6> <div class="article__header" data-astro-cid-axzg2cw6> <ul class="article__categories categories" data-astro-cid-axzg2cw6> <li class="categories__item" data-astro-cid-axzg2cw6> <a href="/category/учебник" class="categories__link" data-astro-cid-axzg2cw6> Учебник  </a> </li> </ul> <h1 class="article__title text-wrap" data-astro-cid-axzg2cw6> 10 лучших алгоритмов сортировки с примерами </h1> <ul class="article__tags tags" data-astro-cid-axzg2cw6> <li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/javascript" data-astro-cid-axzg2cw6> JavaScript </a> </li><li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/python" data-astro-cid-axzg2cw6> Python </a> </li><li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/сортировка" data-astro-cid-axzg2cw6> Сортировка </a> </li> </ul> <time class="article__date" data-astro-cid-axzg2cw6>
Опубликовано 18 дек., 2023 by Игорь Горлов </time> <time class="article__date" data-astro-cid-axzg2cw6> Последнее изменение: 21 мар., 2024 </time> </div>  <figure class="article__image" data-astro-cid-axzg2cw6> <picture> <source srcset="/_astro/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy-Dec-18-2023.BVQlXSG2_1Fjodl.avif" type="image/avif"><source srcset="/_astro/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy-Dec-18-2023.BVQlXSG2_Z1C358k.webp" type="image/webp"> <img src="/_astro/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy-Dec-18-2023.BVQlXSG2_Z2nTtPw.png" alt="10 лучших алгоритмов сортировки с примерами" class="aspect-auto h-full w-full object-cover object-center" loading="eager" data-astro-cid-axzg2cw6 data-astro-transition-scope="astro-vgmtzcrq-1" width="1200" height="500" decoding="async"> </picture> </figure>  <div class="article__content prose prose-zinc max-w-full dark:prose-invert prose-p:text-balance prose-a:no-underline hover:prose-a:underline prose-figure:-mx-12 prose-figure:w-screen prose-figure:bg-gray-light prose-figure:p-10 prose-figcaption:text-dark dark:prose-figure:bg-dark dark:prose-figcaption:text-white" data-astro-cid-axzg2cw6> <div id="adfox_17062261612859555"></div> <script>(function(){const blockId = "adfox_17062261612859555";

	window.yaContextCb = window.yaContextCb || [];
	window.yaContextCb.push(() => {
		Ya.adfoxCode.createAdaptive(
			{
				ownerId: 1493338,
				containerId: blockId,
				params: {
					p1: 'dawgg',
					p2: 'p',
				},
			},
			['desktop', 'tablet', 'phone'],
			{
				tabletWidth: 830,
				phoneWidth: 480,
				isAutoReloads: true,
			},
		);
	});
})();</script> <div class="article__meta" data-astro-cid-axzg2cw6> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=10 лучших алгоритмов сортировки с примерами&#38;url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy&#38;title=10 лучших алгоритмов сортировки с примерами&#38;summary=Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy&#38;media=&#38;description=Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <a class="article__meta-section" href="#comments" data-astro-cid-axzg2cw6> Комментарии</a> </div> <details open class="toc px-5 border border-gray-light lg:px-10 py-2 cursor-pointer"><summary class="toc__title text-xl font-medium">Содержание</summary><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#что-такое-алгоритм-сортировки">Что такое алгоритм сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#для-чего-используются-алгоритмы-сортировки">Для чего используются алгоритмы сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#почему-алгоритмы-сортировки-так-важны">Почему алгоритмы сортировки так важны?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#различные-типы-сортировки-в-структурах-данных">Различные типы сортировки в структурах данных</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-основанные-на-сравнении">Алгоритмы сортировки, основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-не-основанные-на-сравнении">Алгоритмы сортировки, не основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-на-месте">Алгоритмы сортировки на месте</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#стабильные-алгоритмы-сортировки">Стабильные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#адаптивные-алгоритмы-сортировки">Адаптивные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#пузырьковая-сортировка">Пузырьковая сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-и-недостатки-пузырьковой-сортировки">Преимущества и недостатки пузырьковой сортировки</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#что-такое-алгоритм-сортировки-1">Что такое алгоритм сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#для-чего-используются-алгоритмы-сортировки-1">Для чего используются алгоритмы сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#почему-алгоритмы-сортировки-так-важны-1">Почему алгоритмы сортировки так важны?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#различные-типы-сортировки-в-структурах-данных-1">Различные типы сортировки в структурах данных</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-основанные-на-сравнении-1">Алгоритмы сортировки, основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-не-основанные-на-сравнении-1">Алгоритмы сортировки, не основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-на-месте-1">Алгоритмы сортировки на месте</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#стабильные-алгоритмы-сортировки-1">Стабильные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#адаптивные-алгоритмы-сортировки-1">Адаптивные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#пузырьковая-сортировка-1">Пузырьковая сортировка</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#что-такое-алгоритм-сортировки-2">Что такое алгоритм сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#для-чего-используются-алгоритмы-сортировки-2">Для чего используются алгоритмы сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#почему-алгоритмы-сортировки-так-важны-2">Почему алгоритмы сортировки так важны?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#различные-типы-сортировки-в-структурах-данных-2">Различные типы сортировки в структурах данных</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-основанные-на-сравнении-2">Алгоритмы сортировки, основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-не-основанные-на-сравнении-2">Алгоритмы сортировки, не основанные на сравнении</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#алгоритмы-сортировки-на-месте-2">Алгоритмы сортировки на месте</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#стабильные-алгоритмы-сортировки-2">Стабильные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#адаптивные-алгоритмы-сортировки-2">Адаптивные алгоритмы сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#пузырьковая-сортировка-2">Пузырьковая сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-пузырьковой-сортировки">Примеры использования пузырьковой сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-пузырьковой-сортировки">Реализация пузырьковой сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#пузырьковая-сортировка-в-python">Пузырьковая сортировка в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#пузырьковая-сортировка-в-javascript">Пузырьковая сортировка в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#сортировка-вставкой">Сортировка вставкой</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-и-недостатки-сортировки-вставками">Преимущества и недостатки сортировки вставками</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-сортировки-вставками">Примеры использования сортировки вставками</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-вставкой">Реализация сортировки вставкой</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#сортировка-вставкой-в-python">Сортировка вставкой в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#сортировка-вставкой-в-javascript">Сортировка вставкой в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#зыковая-сортировка">Зыковая сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#основные-шаги-сортировки-включают">Основные шаги сортировки включают:</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-сортировки">Преимущества сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#недостатки-сортировки">Недостатки сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-quicksort">Примеры использования quicksort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-quicksort">Реализация Quicksort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#quicksort-в-python">Quicksort в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#зыбкая-сортировка-в-javascript">Зыбкая сортировка в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#ведерная-сортировка">Ведерная сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#основные-шаги-сортировки-по-ведрам-включают">Основные шаги сортировки по ведрам включают:</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#недостатки-ведерной-сортировки">Недостатки ведерной сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#история-ведерной-сортировки">История ведерной сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#случаи-использования-bucket-sort">Случаи использования bucket sort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-по-ведрам">Реализация сортировки по ведрам</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#bucket-sort-в-python">Bucket sort в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#сортировка-ведер-в-javascript">Сортировка ведер в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#shell-sort">Shell sort</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-сортировки-по-оболочке">Преимущества сортировки по оболочке</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#недостатки-shell-sort">Недостатки shell sort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#использование-sases-для-shell-sort">Использование sases для shell sort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-в-оболочке">Реализация сортировки в оболочке</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-в-оболочке-на-языке-python">Реализация сортировки в оболочке на языке Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-в-javascript">Реализация сортировки в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#сортировка-слиянием">Сортировка слиянием</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#недостатки-сортировки-слиянием">Недостатки сортировки слиянием</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#история-сортировки-слиянием">История сортировки слиянием</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-сортировки-слиянием">Примеры использования сортировки слиянием</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-слиянием">Реализация сортировки слиянием</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-слиянием-в-python">Реализация сортировки слиянием в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-слиянием-на-javascript">Реализация сортировки слиянием на JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#сортировка-по-выбору">Сортировка по выбору</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-сортировки-по-выбору">Преимущества сортировки по выбору</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#недостатки-сортировки-по-выбору">Недостатки сортировки по выбору</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-сортировки-по-выбору">Примеры использования сортировки по выбору</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-по-выбору">Реализация сортировки по выбору</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-по-выбору-в-python">Реализация сортировки по выбору в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-сортировки-по-выбору-в-javascript">Реализация сортировки по выбору в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#радиксная-сортировка">Радиксная сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#история-радиксной-сортировки">История радиксной сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#случаи-использования-радиксной-сортировки">Случаи использования радиксной сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-radix-sort">Реализация Radix sort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-радиксной-сортировки-в-python">Реализация радиксной сортировки в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-радиксной-сортировки-в-javascript">Реализация радиксной сортировки в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#комбинированная-сортировка">Комбинированная сортировка</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-гребневой-сортировки">Преимущества гребневой сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-гребенчатой-сортировки">Примеры использования гребенчатой сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-комбинированной-сортировки">Реализация комбинированной сортировки</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-комбинированной-сортировки-в-python">Реализация комбинированной сортировки в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-комбинированной-сортировки-на-javascript">Реализация комбинированной сортировки на JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#timsort">Timsort</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#преимущества-timsort">Преимущества Timsort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#история-timsort">История Timsort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#примеры-использования-timsort">Примеры использования Timsort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-timsort">Реализация Timsort</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-timsort-в-python">Реализация Timsort в Python</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#реализация-timsort-в-javascript">Реализация Timsort в JavaScript</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#сравнение-всех-алгоритмов-сортировки">Сравнение всех алгоритмов сортировки</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#какой-самый-распространенный-алгоритм-сортировки">Какой самый распространенный алгоритм сортировки?</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#заключительные-мысли">Заключительные мысли</a></li></ol></details open><p>Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая организацией музыкальных плейлистов. Но что именно представляют собой алгоритмы сортировки и как они работают? Мы ответим на этот вопрос в этой статье, предоставив полный обзор алгоритмов различных типов и их применения, включая примеры кода.</p>
<p>Возможно, мы немного затронем технические моменты, например, используем нотацию big O для анализа временной и пространственной сложности различных алгоритмов. Но мы также предоставим высокоуровневые обзоры, которые должны быть понятны большинству.</p>
<p>Это, конечно, долгое чтение, так что давайте приступим к нему!</p>
<p>Что такое алгоритм сортировки? Для чего используются алгоритмы сортировки? Почему алгоритмы сортировки так важны? Различные типы сортировки в структурах данных</p>
<p>Сравнение всех алгоритмов сортировки Какой самый распространенный алгоритм сортировки?</p>
<h2 id="что-такое-алгоритм-сортировки">Что такое алгоритм сортировки?<a aria-hidden="true" tabindex="-1" href="#что-такое-алгоритм-сортировки"><span class="icon icon-link"></span></a></h2>
<p>По сути, алгоритм сортировки - это компьютерная программа, которая упорядочивает данные в определенном порядке, например в алфавитном или числовом, обычно либо по возрастанию, либо по убыванию.</p>
<h2 id="для-чего-используются-алгоритмы-сортировки">Для чего используются алгоритмы сортировки?<a aria-hidden="true" tabindex="-1" href="#для-чего-используются-алгоритмы-сортировки"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки в основном используются для эффективной перегруппировки больших объемов данных, чтобы облегчить поиск и работу с ними. Они также используются для повышения эффективности других алгоритмов, таких как поиск и объединение, которые опираются на отсортированные данные для своих операций.</p>
<h2 id="почему-алгоритмы-сортировки-так-важны">Почему алгоритмы сортировки так важны?<a aria-hidden="true" tabindex="-1" href="#почему-алгоритмы-сортировки-так-важны"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки используются для упорядочивания данных в определенном порядке, что облегчает их поиск, доступ и анализ. Во многих приложениях сортировка является критически важной частью конвейера обработки данных, и эффективность алгоритма сортировки может существенно влиять на общую производительность системы.</p>
<p>В базах данных. Сортировка используется для получения записей в определенном порядке, например по дате, в алфавитном или числовом порядке. Это позволяет пользователям быстро находить нужные им данные, не прибегая к ручному поиску в больших объемах несортированных данных.</p>
<p>В поисковых системах. Ранжирование результатов поиска в порядке их релевантности. Сортируя результаты таким образом, пользователи могут быстро найти нужную информацию, не просеивая неактуальные или несвязанные результаты.</p>
<p>Во многих научных и инженерных приложениях. Исследователи могут проводить анализ данных и моделирование, чтобы получить представление о сложных системах и сделать более точные прогнозы относительно будущего поведения.</p>
<h2 id="различные-типы-сортировки-в-структурах-данных">Различные типы сортировки в структурах данных<a aria-hidden="true" tabindex="-1" href="#различные-типы-сортировки-в-структурах-данных"><span class="icon icon-link"></span></a></h2>
<p>Существуют различные типы сортировки. Выбор алгоритма сортировки зависит от различных факторов, таких как размер набора данных, тип сортируемых данных, а также желаемая временная и пространственная сложность.</p>
<h2 id="алгоритмы-сортировки-основанные-на-сравнении">Алгоритмы сортировки, основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-основанные-на-сравнении"><span class="icon icon-link"></span></a></h2>
<p>Они сравнивают элементы набора данных и определяют их порядок на основе результатов сравнения. Примеры алгоритмов сортировки на основе сравнения включают пузырьковую сортировку, сортировку вставкой, квиксорт, сортировку слиянием и сортировку кучей.</p>
<h2 id="алгоритмы-сортировки-не-основанные-на-сравнении">Алгоритмы сортировки, не основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-не-основанные-на-сравнении"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы не сравнивают элементы напрямую, а используют другие свойства набора данных для определения их порядка. Примерами алгоритмов сортировки, не основанных на сравнении, являются счетная сортировка, радиксная сортировка и сортировка по ведрам.</p>
<h2 id="алгоритмы-сортировки-на-месте">Алгоритмы сортировки на месте<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-на-месте"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы сортируют набор данных на месте, то есть не требуют дополнительной памяти для хранения промежуточных результатов. Примерами алгоритмов сортировки на месте являются пузырьковая сортировка, сортировка вставкой, сортировка quicksort и сортировка оболочкой.</p>
<h2 id="стабильные-алгоритмы-сортировки">Стабильные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#стабильные-алгоритмы-сортировки"><span class="icon icon-link"></span></a></h2>
<p>Сохраняют относительный порядок одинаковых элементов в наборе данных. Примерами стабильных алгоритмов сортировки являются сортировка вставкой, сортировка слиянием и Timsort.</p>
<h2 id="адаптивные-алгоритмы-сортировки">Адаптивные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#адаптивные-алгоритмы-сортировки"><span class="icon icon-link"></span></a></h2>
<p>Используют любой существующий порядок в наборе данных для повышения эффективности. Примерами адаптивных алгоритмов сортировки являются сортировка вставками, пузырьковая сортировка и Timsort.</p>
<p>Теперь давайте рассмотрим десять лучших алгоритмов сортировки, о которых следует знать при выборе.</p>
<h2 id="пузырьковая-сортировка">Пузырьковая сортировка<a aria-hidden="true" tabindex="-1" href="#пузырьковая-сортировка"><span class="icon icon-link"></span></a></h2>
<p>Пузырьковая сортировка - это простой алгоритм сортировки, который многократно проходит через заданный список элементов, сравнивая каждую пару соседних элементов и меняя их местами, если они расположены в неправильном порядке. Алгоритм работает до тех пор, пока не пройдет через весь список, не поменяв местами ни одного элемента.</p>
<p>Пузырьковую сортировку также иногда называют ”тонущей сортировкой”.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851747bubble-sort-example.Ce7hMPjR_Z1az13r.webp" alt="1680851747bubble-sort-example.gif" width="300" height="180" loading="lazy" decoding="async"><figcaption>1680851747bubble-sort-example.gif</figcaption></figure>
<p>Начиная с начала списка, сравните каждую соседнюю пару, поменяйте их местами, если они расположены не в правильном порядке (последний элемент меньше первого). После каждой итерации нужно сравнивать на один элемент меньше (последний), пока не останется ни одного элемента, который можно было бы сравнить. : Wikimedia Commons, CC BY-SA 3.0. История пузырьковой сортировки</p>
<p>История возникновения пузырьковой сортировки восходит к концу 1950-х годов, а Дональд Кнут популяризировал ее в своей классической книге 1968 года The Art of Computer Programming.</p>
<p>С тех пор она широко используется в различных приложениях, включая алгоритмы сортировки для компиляторов, сортировку элементов в базах данных и даже сортировку игральных карт.</p>
<h3 id="преимущества-и-недостатки-пузырьковой-сортировки">Преимущества и недостатки пузырьковой сортировки<a aria-hidden="true" tabindex="-1" href="#преимущества-и-недостатки-пузырьковой-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Пузырьковая сортировка считается относительно неэффективным алгоритмом сортировки, поскольку ее средняя и наихудшая сложность составляют `$O(n^2)---</p>
<p>title: 10 лучших алгоритмов сортировки с примерами
meta_title: ’’
description: ”
date: 2023-12-18T00:00:00.000Z
categories:</p>
<ul>
<li>python</li>
<li>novosti
author: Игорь Горлов
type: blog
draft: false
slug: 10-luchshykh-alhorytmov-sortyrovky-s-prymeramy</li>
</ul>
<hr>
<p>Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая организацией музыкальных плейлистов. Но что именно представляют собой алгоритмы сортировки и как они работают? Мы ответим на этот вопрос в этой статье, предоставив полный обзор алгоритмов различных типов и их применения, включая примеры кода.</p>
<p>Возможно, мы немного затронем технические моменты, например, используем нотацию big O для анализа временной и пространственной сложности различных алгоритмов. Но мы также предоставим высокоуровневые обзоры, которые должны быть понятны большинству.</p>
<p>Это, конечно, долгое чтение, так что давайте приступим к нему!</p>
<p>Что такое алгоритм сортировки? Для чего используются алгоритмы сортировки? Почему алгоритмы сортировки так важны? Различные типы сортировки в структурах данных</p>
<p>Сравнение всех алгоритмов сортировки Какой самый распространенный алгоритм сортировки?</p>
<h2 id="что-такое-алгоритм-сортировки-1">Что такое алгоритм сортировки?<a aria-hidden="true" tabindex="-1" href="#что-такое-алгоритм-сортировки-1"><span class="icon icon-link"></span></a></h2>
<p>По сути, алгоритм сортировки - это компьютерная программа, которая упорядочивает данные в определенном порядке, например в алфавитном или числовом, обычно либо по возрастанию, либо по убыванию.</p>
<h2 id="для-чего-используются-алгоритмы-сортировки-1">Для чего используются алгоритмы сортировки?<a aria-hidden="true" tabindex="-1" href="#для-чего-используются-алгоритмы-сортировки-1"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки в основном используются для эффективной перегруппировки больших объемов данных, чтобы облегчить поиск и работу с ними. Они также используются для повышения эффективности других алгоритмов, таких как поиск и объединение, которые опираются на отсортированные данные для своих операций.</p>
<h2 id="почему-алгоритмы-сортировки-так-важны-1">Почему алгоритмы сортировки так важны?<a aria-hidden="true" tabindex="-1" href="#почему-алгоритмы-сортировки-так-важны-1"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки используются для упорядочивания данных в определенном порядке, что облегчает их поиск, доступ и анализ. Во многих приложениях сортировка является критически важной частью конвейера обработки данных, и эффективность алгоритма сортировки может существенно влиять на общую производительность системы.</p>
<p>В базах данных. Сортировка используется для получения записей в определенном порядке, например по дате, в алфавитном или числовом порядке. Это позволяет пользователям быстро находить нужные им данные, не прибегая к ручному поиску в больших объемах несортированных данных.</p>
<p>В поисковых системах. Ранжирование результатов поиска в порядке их релевантности. Сортируя результаты таким образом, пользователи могут быстро найти нужную информацию, не просеивая неактуальные или несвязанные результаты.</p>
<p>Во многих научных и инженерных приложениях. Исследователи могут проводить анализ данных и моделирование, чтобы получить представление о сложных системах и сделать более точные прогнозы относительно будущего поведения.</p>
<h2 id="различные-типы-сортировки-в-структурах-данных-1">Различные типы сортировки в структурах данных<a aria-hidden="true" tabindex="-1" href="#различные-типы-сортировки-в-структурах-данных-1"><span class="icon icon-link"></span></a></h2>
<p>Существуют различные типы сортировки. Выбор алгоритма сортировки зависит от различных факторов, таких как размер набора данных, тип сортируемых данных, а также желаемая временная и пространственная сложность.</p>
<h2 id="алгоритмы-сортировки-основанные-на-сравнении-1">Алгоритмы сортировки, основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-основанные-на-сравнении-1"><span class="icon icon-link"></span></a></h2>
<p>Они сравнивают элементы набора данных и определяют их порядок на основе результатов сравнения. Примеры алгоритмов сортировки на основе сравнения включают пузырьковую сортировку, сортировку вставкой, квиксорт, сортировку слиянием и сортировку кучей.</p>
<h2 id="алгоритмы-сортировки-не-основанные-на-сравнении-1">Алгоритмы сортировки, не основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-не-основанные-на-сравнении-1"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы не сравнивают элементы напрямую, а используют другие свойства набора данных для определения их порядка. Примерами алгоритмов сортировки, не основанных на сравнении, являются счетная сортировка, радиксная сортировка и сортировка по ведрам.</p>
<h2 id="алгоритмы-сортировки-на-месте-1">Алгоритмы сортировки на месте<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-на-месте-1"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы сортируют набор данных на месте, то есть не требуют дополнительной памяти для хранения промежуточных результатов. Примерами алгоритмов сортировки на месте являются пузырьковая сортировка, сортировка вставкой, сортировка quicksort и сортировка оболочкой.</p>
<h2 id="стабильные-алгоритмы-сортировки-1">Стабильные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#стабильные-алгоритмы-сортировки-1"><span class="icon icon-link"></span></a></h2>
<p>Сохраняют относительный порядок одинаковых элементов в наборе данных. Примерами стабильных алгоритмов сортировки являются сортировка вставкой, сортировка слиянием и Timsort.</p>
<h2 id="адаптивные-алгоритмы-сортировки-1">Адаптивные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#адаптивные-алгоритмы-сортировки-1"><span class="icon icon-link"></span></a></h2>
<p>Используют любой существующий порядок в наборе данных для повышения эффективности. Примерами адаптивных алгоритмов сортировки являются сортировка вставками, пузырьковая сортировка и Timsort.</p>
<p>Теперь давайте рассмотрим десять лучших алгоритмов сортировки, о которых следует знать при выборе.</p>
<h2 id="пузырьковая-сортировка-1">Пузырьковая сортировка<a aria-hidden="true" tabindex="-1" href="#пузырьковая-сортировка-1"><span class="icon icon-link"></span></a></h2>
<p>Пузырьковая сортировка - это простой алгоритм сортировки, который многократно проходит через заданный список элементов, сравнивая каждую пару соседних элементов и меняя их местами, если они расположены в неправильном порядке. Алгоритм работает до тех пор, пока не пройдет через весь список, не поменяв местами ни одного элемента.</p>
<p>Пузырьковую сортировку также иногда называют ”тонущей сортировкой”.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851747bubble-sort-example.Ce7hMPjR_Z1az13r.webp" alt="1680851747bubble-sort-example.gif" width="300" height="180" loading="lazy" decoding="async"><figcaption>1680851747bubble-sort-example.gif</figcaption></figure>
<p>Начиная с начала списка, сравните каждую соседнюю пару, поменяйте их местами, если они расположены не в правильном порядке (последний элемент меньше. Это делает его гораздо менее эффективным, чем большинство других алгоритмов сортировки, таких как quicksort или mergesort.</p>
<p>Техническое примечание: сложность `$O(n^2)---</p>
<p>title: 10 лучших алгоритмов сортировки с примерами
meta_title: ’’
description: ”
date: 2023-12-18T00:00:00.000Z
categories:</p>
<ul>
<li>python</li>
<li>novosti
author: Игорь Горлов
type: blog
draft: false
slug: 10-luchshykh-alhorytmov-sortyrovky-s-prymeramy</li>
</ul>
<hr>
<p>Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая организацией музыкальных плейлистов. Но что именно представляют собой алгоритмы сортировки и как они работают? Мы ответим на этот вопрос в этой статье, предоставив полный обзор алгоритмов различных типов и их применения, включая примеры кода.</p>
<p>Возможно, мы немного затронем технические моменты, например, используем нотацию big O для анализа временной и пространственной сложности различных алгоритмов. Но мы также предоставим высокоуровневые обзоры, которые должны быть понятны большинству.</p>
<p>Это, конечно, долгое чтение, так что давайте приступим к нему!</p>
<p>Что такое алгоритм сортировки? Для чего используются алгоритмы сортировки? Почему алгоритмы сортировки так важны? Различные типы сортировки в структурах данных</p>
<p>Сравнение всех алгоритмов сортировки Какой самый распространенный алгоритм сортировки?</p>
<h2 id="что-такое-алгоритм-сортировки-2">Что такое алгоритм сортировки?<a aria-hidden="true" tabindex="-1" href="#что-такое-алгоритм-сортировки-2"><span class="icon icon-link"></span></a></h2>
<p>По сути, алгоритм сортировки - это компьютерная программа, которая упорядочивает данные в определенном порядке, например в алфавитном или числовом, обычно либо по возрастанию, либо по убыванию.</p>
<h2 id="для-чего-используются-алгоритмы-сортировки-2">Для чего используются алгоритмы сортировки?<a aria-hidden="true" tabindex="-1" href="#для-чего-используются-алгоритмы-сортировки-2"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки в основном используются для эффективной перегруппировки больших объемов данных, чтобы облегчить поиск и работу с ними. Они также используются для повышения эффективности других алгоритмов, таких как поиск и объединение, которые опираются на отсортированные данные для своих операций.</p>
<h2 id="почему-алгоритмы-сортировки-так-важны-2">Почему алгоритмы сортировки так важны?<a aria-hidden="true" tabindex="-1" href="#почему-алгоритмы-сортировки-так-важны-2"><span class="icon icon-link"></span></a></h2>
<p>Алгоритмы сортировки используются для упорядочивания данных в определенном порядке, что облегчает их поиск, доступ и анализ. Во многих приложениях сортировка является критически важной частью конвейера обработки данных, и эффективность алгоритма сортировки может существенно влиять на общую производительность системы.</p>
<p>В базах данных. Сортировка используется для получения записей в определенном порядке, например по дате, в алфавитном или числовом порядке. Это позволяет пользователям быстро находить нужные им данные, не прибегая к ручному поиску в больших объемах несортированных данных.</p>
<p>В поисковых системах. Ранжирование результатов поиска в порядке их релевантности. Сортируя результаты таким образом, пользователи могут быстро найти нужную информацию, не просеивая неактуальные или несвязанные результаты.</p>
<p>Во многих научных и инженерных приложениях. Исследователи могут проводить анализ данных и моделирование, чтобы получить представление о сложных системах и сделать более точные прогнозы относительно будущего поведения.</p>
<h2 id="различные-типы-сортировки-в-структурах-данных-2">Различные типы сортировки в структурах данных<a aria-hidden="true" tabindex="-1" href="#различные-типы-сортировки-в-структурах-данных-2"><span class="icon icon-link"></span></a></h2>
<p>Существуют различные типы сортировки. Выбор алгоритма сортировки зависит от различных факторов, таких как размер набора данных, тип сортируемых данных, а также желаемая временная и пространственная сложность.</p>
<h2 id="алгоритмы-сортировки-основанные-на-сравнении-2">Алгоритмы сортировки, основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-основанные-на-сравнении-2"><span class="icon icon-link"></span></a></h2>
<p>Они сравнивают элементы набора данных и определяют их порядок на основе результатов сравнения. Примеры алгоритмов сортировки на основе сравнения включают пузырьковую сортировку, сортировку вставкой, квиксорт, сортировку слиянием и сортировку кучей.</p>
<h2 id="алгоритмы-сортировки-не-основанные-на-сравнении-2">Алгоритмы сортировки, не основанные на сравнении<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-не-основанные-на-сравнении-2"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы не сравнивают элементы напрямую, а используют другие свойства набора данных для определения их порядка. Примерами алгоритмов сортировки, не основанных на сравнении, являются счетная сортировка, радиксная сортировка и сортировка по ведрам.</p>
<h2 id="алгоритмы-сортировки-на-месте-2">Алгоритмы сортировки на месте<a aria-hidden="true" tabindex="-1" href="#алгоритмы-сортировки-на-месте-2"><span class="icon icon-link"></span></a></h2>
<p>Эти алгоритмы сортируют набор данных на месте, то есть не требуют дополнительной памяти для хранения промежуточных результатов. Примерами алгоритмов сортировки на месте являются пузырьковая сортировка, сортировка вставкой, сортировка quicksort и сортировка оболочкой.</p>
<h2 id="стабильные-алгоритмы-сортировки-2">Стабильные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#стабильные-алгоритмы-сортировки-2"><span class="icon icon-link"></span></a></h2>
<p>Сохраняют относительный порядок одинаковых элементов в наборе данных. Примерами стабильных алгоритмов сортировки являются сортировка вставкой, сортировка слиянием и Timsort.</p>
<h2 id="адаптивные-алгоритмы-сортировки-2">Адаптивные алгоритмы сортировки<a aria-hidden="true" tabindex="-1" href="#адаптивные-алгоритмы-сортировки-2"><span class="icon icon-link"></span></a></h2>
<p>Используют любой существующий порядок в наборе данных для повышения эффективности. Примерами адаптивных алгоритмов сортировки являются сортировка вставками, пузырьковая сортировка и Timsort.</p>
<p>Теперь давайте рассмотрим десять лучших алгоритмов сортировки, о которых следует знать при выборе.</p>
<h2 id="пузырьковая-сортировка-2">Пузырьковая сортировка<a aria-hidden="true" tabindex="-1" href="#пузырьковая-сортировка-2"><span class="icon icon-link"></span></a></h2>
<p>Пузырьковая сортировка - это простой алгоритм сортировки, который многократно проходит через заданный список элементов, сравнивая каждую пару соседних элементов и меняя их местами, если они расположены в неправильном порядке. Алгоритм работает до тех пор, пока не пройдет через весь список, не поменяв местами ни одного элемента.</p>
<p>Пузырьковую сортировку также иногда называют ”тонущей сортировкой”.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851747bubble-sort-example.Ce7hMPjR_Z1az13r.webp" alt="1680851747bubble-sort-example.gif" width="300" height="180" loading="lazy" decoding="async"><figcaption>1680851747bubble-sort-example.gif</figcaption></figure>
<p>Начиная с начала списка, сравните каждую соседнюю пару, поменяйте их местами, если они расположены не в правильном порядке (последний элемент меньше означает, что время, необходимое алгоритму для завершения работы, пропорционально квадрату размера входных данных. Это означает, что при больших размерах входных данных алгоритм работает значительно дольше.</p>
<p>Например, если вы рассматриваете алгоритм, сортирующий массив чисел, то сортировка массива из десяти чисел может занять одну секунду, а сортировка массива из 20 чисел - четыре секунды. Это связано с тем, что алгоритм должен сравнить каждый элемент массива с каждым другим элементом, поэтому для большего массива он должен выполнить 20 сравнений, а для меньшего - всего десять.</p>
<p>Однако этот алгоритм очень прост для понимания и реализации, и его часто используют в качестве введения в сортировку и как строительный блок для более сложных алгоритмов. Однако в наши дни она редко используется на практике.</p>
<h3 id="примеры-использования-пузырьковой-сортировки">Примеры использования пузырьковой сортировки<a aria-hidden="true" tabindex="-1" href="#примеры-использования-пузырьковой-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Пузырьковая сортировка - это простой алгоритм, который можно использовать для сортировки небольших списков или массивов элементов. Его легко реализовать и понять, поэтому его можно использовать в ситуациях, когда простота и ясность важнее производительности.</p>
<p>Образовательные цели. Часто используется в курсах информатики в качестве примера простого алгоритма сортировки. Изучая bubble sort, студенты могут узнать об основных методах сортировки и получить представление о том, как работают алгоритмы.</p>
<p>Сортировка небольших наборов данных. Она может использоваться для сортировки небольших наборов данных до нескольких сотен элементов. В случаях, когда производительность не является критически важным фактором, пузырьковая сортировка может быть быстрым и простым способом сортировки небольших списков.</p>
<p>Предварительная сортировка данных. Может использоваться в качестве предварительного шага в более сложных алгоритмах сортировки. Например, если данные уже частично отсортированы, пузырьковая сортировка может быть использована для дальнейшей сортировки данных перед запуском более сложного алгоритма.</p>
<p>Сортировка данных при ограниченных ресурсах. Она полезна в ситуациях, когда ресурсы ограничены, например во встраиваемых системах или микроконтроллерах, поскольку требует очень мало памяти и вычислительной мощности.</p>
<p>Строительные блоки для более сложных алгоритмов. Часто используется в сочетании с сортировкой слиянием или сортировкой квиксором, а также сортировкой небольших подмассивов с помощью сортировки вставкой, поскольку эти алгоритмы могут достигать лучшей производительности на больших наборах данных.</p>
<h3 id="реализация-пузырьковой-сортировки">Реализация пузырьковой сортировки<a aria-hidden="true" tabindex="-1" href="#реализация-пузырьковой-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Используйте вложенные циклы для перебора элементов. Сравнивайте соседние элементы в списке. Поменяйте местами элементы, если они расположены в неправильном порядке. Продолжайте, пока список не будет отсортирован.</p>
<h3 id="пузырьковая-сортировка-в-python">Пузырьковая сортировка в Python<a aria-hidden="true" tabindex="-1" href="#пузырьковая-сортировка-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def bubble_sort(items): for i in range(len(items)): for j in range(len(items)-1-i): if items[j] > items[j+1]: items[j], items[j+1] = items[j+1], items[j] return items = [6,20,8,19,56,23,87,41,49,53] print(bubble_sort(items))</code></p>
<h3 id="пузырьковая-сортировка-в-javascript">Пузырьковая сортировка в JavaScript<a aria-hidden="true" tabindex="-1" href="#пузырьковая-сортировка-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function bubbleSort(items) { let swapped; do { swapped = false; for (let i = 0; i &#x3C; items.length - 1; i++) { if (items[i] > items[i + 1]) { let temp = items[i]; items[i] = items[i + 1]; items[i + 1] = temp; swapped = true; } } } while (swapped); return items; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(bubbleSort(items));</code></p>
<h2 id="сортировка-вставкой">Сортировка вставкой<a aria-hidden="true" tabindex="-1" href="#сортировка-вставкой"><span class="icon icon-link"></span></a></h2>
<p>Сортировка вставкой - это еще один простой алгоритм, который строит окончательный отсортированный массив по одному элементу за раз, и назван он так за то, как маленькие элементы вставляются на свои места в отсортированном массиве.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851756insertion-sort-example.DHREo0JS_2cLfTY.webp" alt="1680851756insertion-sort-example.gif" width="300" height="180" loading="lazy" decoding="async"><figcaption>1680851756insertion-sort-example.gif</figcaption></figure>
<p>Частично отсортированный список изначально содержит только первый элемент. С каждой итерацией один элемент удаляется из входных данных ”еще не проверен на порядок” и вставляется на место в отсортированный список. : Wikimedia Commons, CC BY-SA 3.0. История сортировки вставкой</p>
<p>В книге ”Искусство компьютерного программирования” Кнут отмечает, что сортировка вставкой “была упомянута Джоном Маучли еще в 1946 году, в первом опубликованном обсуждении компьютерной сортировки”, описывая ее как “естественный” алгоритм, который легко понять и реализовать.</p>
<p>К концу 1950-х годов Дональд Л. Шелл внес ряд улучшений в свой метод сортировки Шелла (о котором речь пойдет ниже), который сравнивает элементы, разделенные расстоянием, уменьшающимся при каждом проходе, что позволило снизить сложность алгоритма до <code>$O(n^{3/2})$</code> и <code>$O(n^{4/3})$</code> в двух различных вариантах. Это может показаться не очень большим, но для практических приложений это довольно значительное улучшение!</p>
<p>Технические примечания: Сложности <code>$O(n^{3/2})$</code> и <code>$O(n^{4/3})$</code> являются более эффективными, чем сложность <code>$O(n^2)$</code>, то есть требуют меньше времени для завершения. Это связано с тем, что им не нужно выполнять столько сравнений, как сложности <code>$O(n^2)$</code>.</p>
<p>Например, сортировка массива из десяти чисел с помощью алгоритма <code>$O(n^2)$</code> может занять одну секунду, а сортировка того же массива с помощью алгоритма <code>$O(n^{3/2})$</code> может занять 0,5 секунды. Это происходит потому, что алгоритм может выполнять меньше сравнений при использовании алгоритма <code>$O(n^{3/2})$</code>, что приводит к более быстрому времени выполнения.</p>
<p>В 2006 году Бендер, Мартин Фарах-Колтон и Мостейро опубликовали новый вариант сортировки вставками, названный библиотечной сортировкой или ”сортировкой вставками с зазором”, которая оставляет небольшое количество неиспользуемых пробелов (или “пробелов”) по всему массиву, что еще больше увеличивает время работы до <code>$O(n log n)$</code>.</p>
<p>Технические примечания: Сложность <code>$O(n log n)$</code> эффективнее сложности <code>$O(n^2)$</code>, а также сложностей <code>$O(n^{3/2})$</code> и <code>$O(n^{4/3})$</code>. Это связано с тем, что в нем используется подход ”разделяй и властвуй”, то есть он может разбить задачу на более мелкие части и решить их быстрее.</p>
<p>Например, сортировка массива из десяти чисел алгоритмом <code>$O(n^2)$</code> может занять одну секунду, сортировка того же массива алгоритмом <code>$O(n^{3/2})$</code> - 0,5 секунды, а сортировка того же массива алгоритмом <code>$O(n log n)$</code> может занять 0,1 секунды. Это происходит потому, что алгоритм может разбивать массив на более мелкие части и решать их параллельно, что приводит к более быстрому времени выполнения.</p>
<h3 id="преимущества-и-недостатки-сортировки-вставками">Преимущества и недостатки сортировки вставками<a aria-hidden="true" tabindex="-1" href="#преимущества-и-недостатки-сортировки-вставками"><span class="icon icon-link"></span></a></h3>
<p>Сортировка вставкой часто используется на практике для небольших наборов данных или в качестве строительного блока для более сложных алгоритмов.</p>
<p>Как и в случае с пузырьковой сортировкой, ее наихудшая и средняя временная сложность составляет <code>$O(n^2)$</code>. Но в отличие от пузырьковой сортировки, сортировка вставками может использоваться для сортировки наборов данных in-place, что означает, что она не требует дополнительной памяти для хранения промежуточных результатов.</p>
<h3 id="примеры-использования-сортировки-вставками">Примеры использования сортировки вставками<a aria-hidden="true" tabindex="-1" href="#примеры-использования-сортировки-вставками"><span class="icon icon-link"></span></a></h3>
<p>Простая и эффективная сортировка вставками часто используется в ситуациях, когда входные данные уже частично отсортированы, или когда размер входных данных относительно мал. Она также используется для сортировки небольших наборов данных и как строительный блок для более сложных алгоритмов, как и пузырьковая сортировка.</p>
<p>Частично отсортированные данные. Хорошо подходит для ситуаций, когда данные уже частично отсортированы. В этом случае алгоритм может быстро вставить новые элементы в нужные позиции, не прибегая к сложным операциям сортировки.</p>
<p>Онлайн-сортировка. Часто используется для онлайн-сортировки, когда входные данные не известны заранее. В таких случаях алгоритм может инкрементально сортировать входные данные по мере их получения.</p>
<p>Адаптивная сортировка. Сортировка вставками является кандидатом на адаптивную сортировку, поскольку она может использовать существующий порядок во входных данных. По мере того как входные данные становятся более упорядоченными, производительность алгоритма повышается.</p>
<h3 id="реализация-сортировки-вставкой">Реализация сортировки вставкой<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-вставкой"><span class="icon icon-link"></span></a></h3>
<p>Возьмите несортированный список и выберите первый элемент в качестве ”поворотного”. Пройдитесь по списку, вставляя стержень на нужное место в отсортированном списке. Повторите процесс со следующим элементом списка. Продолжайте, пока список не будет отсортирован.</p>
<h3 id="сортировка-вставкой-в-python">Сортировка вставкой в Python<a aria-hidden="true" tabindex="-1" href="#сортировка-вставкой-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def insertion_sort(items): for i in range(1, len(items)): j = i while j > 0 and items[j-1] > items[j]: items[j-1], items[j] = items[j], items[j-1] j -= 1 return items items = [6,20,8,19,56,23,87,41,49,53] print(insertion_sort(items))</code>.</p>
<h3 id="сортировка-вставкой-в-javascript">Сортировка вставкой в JavaScript<a aria-hidden="true" tabindex="-1" href="#сортировка-вставкой-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function insertionSort(items) { for (let i = 1; i &#x3C; items.length; i++) { let j = i; while (j > 0 &#x26;&#x26; items[j - 1] > items[j]) { let temp = items[j]; items[j] = items[j - 1]; items[j - 1] = temp; j--; } } return items; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(insertionSort(items));</code></p>
<h2 id="зыковая-сортировка">Зыковая сортировка<a aria-hidden="true" tabindex="-1" href="#зыковая-сортировка"><span class="icon icon-link"></span></a></h2>
<p>Quicksort - это популярный алгоритм сортировки по принципу ”разделяй и властвуй”, основанный на разделении массива на два подмассива: один содержит элементы, меньшие, чем “поворотный” элемент, а другой - элементы, большие, чем поворотный элемент. Затем эти два подмассива сортируются рекурсивно.</p>
<h3 id="основные-шаги-сортировки-включают">Основные шаги сортировки включают:<a aria-hidden="true" tabindex="-1" href="#основные-шаги-сортировки-включают"><span class="icon icon-link"></span></a></h3>
<p>Выбор поворотного элемента из массива. Разбить массив на два подмассива, один из которых содержит элементы, меньшие, чем поворотный, а другой - элементы, большие, чем поворотный. Отсортируйте два подмассива рекурсивно с помощью quicksort. Объедините два отсортированных подмассива.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851760sorting_quicksort.gZxRmu4p_py1Fj.webp" alt="1680851760sorting_quicksort.gif" width="280" height="214" loading="lazy" decoding="async"><figcaption>1680851760sorting_quicksort.gif</figcaption></figure>
<p>Зыковая сортировка была изобретена Тони Хоаром в 1959 году. Хоар работал в британской компьютерной компании Elliott Brothers, когда он разработал алгоритм для сортировки слов в памяти компьютера Ferranti Mark I.</p>
<p>Quicksort был первоначально опубликован как исследовательская работа в 1961 году и быстро стал одним из наиболее широко используемых алгоритмов сортировки благодаря своей простоте, эффективности и легкости реализации.</p>
<h3 id="преимущества-сортировки">Преимущества сортировки<a aria-hidden="true" tabindex="-1" href="#преимущества-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Средняя временная сложность алгоритма составляет <code>$O(n log n)$</code>. Она требует очень мало дополнительной памяти, поскольку сортирует массив на месте. Легко реализуется и широко понимается. Его можно легко распараллелить.</p>
<h3 id="недостатки-сортировки">Недостатки сортировки<a aria-hidden="true" tabindex="-1" href="#недостатки-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Его наихудшая временная сложность составляет <code>$O(n^2)$</code> при плохом выборе точки поворота, что делает его менее эффективным, чем другие алгоритмы, такие как merge sort или heapsort в определенных ситуациях.</p>
<p>Техническое замечание: мы не хотим выбирать слишком маленькую или слишком большую точку поворота, иначе алгоритм будет работать в квадратичном времени. Идеальным вариантом было бы выбрать медиану в качестве точки поворота, но это не всегда возможно, если у нас нет предварительных знаний о распределении данных.</p>
<h3 id="примеры-использования-quicksort">Примеры использования quicksort<a aria-hidden="true" tabindex="-1" href="#примеры-использования-quicksort"><span class="icon icon-link"></span></a></h3>
<p>Как высокоэффективный алгоритм сортировки, quicksort имеет широкий спектр применения.</p>
<p>Большие наборы данных. Его средняя временная сложность составляет <code>$O(n log n)$</code>, что означает, что он может быстро сортировать большие объемы данных.</p>
<p>Случайные данные. Он хорошо справляется с данными, упорядоченными случайным образом, поскольку полагается на поворотный элемент для разделения данных на два подмассива, которые затем рекурсивно сортируются. Когда данные случайны, поворотный элемент, скорее всего, будет близок к медиане, что приводит к хорошей производительности.</p>
<p>Параллельная обработка. Этот метод можно легко распараллелить, что делает его идеальным для сортировки больших массивов данных на многоядерных процессорах. Разбив данные на более мелкие подмассивы, алгоритм может выполняться на нескольких ядрах одновременно, что приводит к повышению производительности.</p>
<p>Внешняя сортировка. Часто используется как часть алгоритма внешней сортировки, который применяется для сортировки данных, слишком больших, чтобы поместиться в памяти. В этом случае данные сортируются на куски, которые затем объединяются с помощью алгоритма слияния-сортировки.</p>
<p>Сжатие данных. Используется в некоторых алгоритмах сжатия данных, например в преобразовании Берроуза-Уиллера, которое применяется в программе сжатия bzip2. Алгоритм используется для сортировки данных в матрице Берроуза-Уиллера, которая затем преобразуется для получения сжатых данных.</p>
<h3 id="реализация-quicksort">Реализация Quicksort<a aria-hidden="true" tabindex="-1" href="#реализация-quicksort"><span class="icon icon-link"></span></a></h3>
<p>Используйте ”поворотную” точку, в идеале медиану, чтобы разделить список на две части. Быстро отсортируйте левую часть и правую часть. Продолжайте, пока список не будет отсортирован.</p>
<h3 id="quicksort-в-python">Quicksort в Python<a aria-hidden="true" tabindex="-1" href="#quicksort-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def quick_sort(items): if len(items) > 1: pivot = items[0] left = [i for i in items[1:] if i &#x3C; pivot] right = [i for i in items[1:] if i >= pivot] return quick_sort(left) + [pivot] + quick_sort(right) else: return items items = [6,20,8,19,56,23,87,41,49,53] print(quick_sort(items))</code></p>
<h3 id="зыбкая-сортировка-в-javascript">Зыбкая сортировка в JavaScript<a aria-hidden="true" tabindex="-1" href="#зыбкая-сортировка-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function quickSort(items) { if (items.length > 1) { let pivot = items[0]; let left = []; let right = []; for (let i = 1; i &#x3C; items.length; i++) { if (items[i] &#x3C; pivot) { left.push(items[i]); } else { right.push(items[i]); } } return quickSort(left).concat(pivot, quickSort(right)); } else { return items; } } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(quickSort(items));</code></p>
<h2 id="ведерная-сортировка">Ведерная сортировка<a aria-hidden="true" tabindex="-1" href="#ведерная-сортировка"><span class="icon icon-link"></span></a></h2>
<p>Bucket sort - полезный алгоритм для сортировки равномерно распределенных данных, и его можно легко распараллелить для повышения производительности.</p>
<h3 id="основные-шаги-сортировки-по-ведрам-включают">Основные шаги сортировки по ведрам включают:<a aria-hidden="true" tabindex="-1" href="#основные-шаги-сортировки-по-ведрам-включают"><span class="icon icon-link"></span></a></h3>
<p>Создайте массив пустых ведер. Распределите входные данные по ведрам в соответствии с заданной функцией. Отсортируйте каждое ведро с помощью другого алгоритма или рекурсивно с помощью bucket sort. Соберите отсортированные элементы из каждого ведра в исходный массив.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851749bucket-sort.CjoHj0la_1D0OLA.webp" alt="1680851749bucket-sort.jpg" width="440" height="400" loading="lazy" decoding="async"><figcaption>1680851749bucket-sort.jpg</figcaption></figure>
<p>Элементы распределяются по бункерам, затем элементы сортируются внутри каждого бункера. Источники изображений: bucket sort 1 и bucket sort 2, Wikimedia Commons, CC BY-SA 4.0. Преимущества ведерной сортировки</p>
<p>Она эффективна для равномерно распределенных данных, ее средняя временная сложность составляет <code>$O(n+k)$</code>, где <code>$n$</code> - количество элементов, а <code>$k$</code> - количество бункеров. Она легко распараллеливается, позволяя использовать преимущества нескольких ядер современных процессоров. Он стабилен, то есть сохраняет относительный порядок одинаковых элементов в исходном массиве. Его можно использовать для данных с неравномерным распределением, настроив функцию bucket.</p>
<p>Техническое примечание: сложность <code>$O(n+k)$</code> эффективнее, чем сложность <code>$O(n^2)$</code>, сложности <code>$O(n^{3/2})$</code> и <code>$O(n^{4/3})$</code>, а также сложность <code>$O(n log n)$</code>. Это связано с тем, что он должен выполнять только линейное количество операций, независимо от размера входных данных.</p>
<p>Например, рассмотрим алгоритм, сортирующий массив чисел. Сортировка массива из десяти чисел с помощью алгоритма <code>$O(n^2)$</code> может занять одну секунду, сортировка того же массива с помощью алгоритма <code>$O(n^{3/2})$</code> - 0,5 секунды, сортировка того же массива с помощью алгоритма <code>$O(n log n)$</code> - 0,1 секунды, но сортировка того же массива с помощью алгоритма <code>$O(n+k)$</code> может занять 0,05 секунды. Это происходит потому, что алгоритму не нужно выполнять столько сравнений.</p>
<h3 id="недостатки-ведерной-сортировки">Недостатки ведерной сортировки<a aria-hidden="true" tabindex="-1" href="#недостатки-ведерной-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Bucket sort менее эффективен, чем другие алгоритмы сортировки, на неравномерно распределенных данных: в худшем случае его производительность составляет <code>$O(n^2)$</code>. Кроме того, она требует дополнительной памяти для хранения ведер, что может быть проблемой для очень больших наборов данных.</p>
<h3 id="история-ведерной-сортировки">История ведерной сортировки<a aria-hidden="true" tabindex="-1" href="#история-ведерной-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Реализации bucket sort появились еще в 1950-х годах, а источники утверждают, что метод существует с 1940-х годов.</p>
<p>В любом случае, он широко используется и в наши дни.</p>
<h3 id="случаи-использования-bucket-sort">Случаи использования bucket sort<a aria-hidden="true" tabindex="-1" href="#случаи-использования-bucket-sort"><span class="icon icon-link"></span></a></h3>
<p>Как и quicksort, bucket sort можно легко распараллелить и использовать для внешней сортировки, но bucket sort особенно полезна при работе с равномерно распределенными данными.</p>
<p>Сортировка чисел с плавающей точкой. В этом случае диапазон делится на фиксированное количество ведер, каждое из которых представляет собой поддиапазон входных данных. Затем числа помещаются в соответствующие ведра и сортируются с помощью другого алгоритма, например сортировки вставкой. Наконец, отсортированные данные объединяются в один массив.</p>
<p>Сортировка строк. Строки группируются в букеты по первой букве строки. Затем строки в каждом ведре сортируются с помощью другого алгоритма или рекурсивно с помощью bucket sort. Этот процесс повторяется для каждой последующей буквы в строках, пока весь набор не будет отсортирован.</p>
<p>Генерация гистограмм. С его помощью можно построить гистограммы данных, которые используются для представления частотного распределения набора значений. В этом случае диапазон данных делится на фиксированное количество ведер, и подсчитывается количество значений в каждом ведре. Полученная гистограмма может быть использована для визуализации распределения данных.</p>
<h3 id="реализация-сортировки-по-ведрам">Реализация сортировки по ведрам<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-по-ведрам"><span class="icon icon-link"></span></a></h3>
<p>Разделите список элементов на ”ведра”. Каждое ведро сортируется с помощью своего алгоритма сортировки. Затем ведра объединяются в один отсортированный список.</p>
<h3 id="bucket-sort-в-python">Bucket sort в Python<a aria-hidden="true" tabindex="-1" href="#bucket-sort-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def bucket_sort(items): buckets = [[] for _ in range(len(items))] for item in items: bucket = int(item/len(items)) buckets[bucket].append(item) for bucket in buckets: bucket.sort() return [item for bucket in buckets for item in bucket] items = [6,20,8,19,56,23,87,41,49,53] print(bucket_sort(items))</code></p>
<h3 id="сортировка-ведер-в-javascript">Сортировка ведер в JavaScript<a aria-hidden="true" tabindex="-1" href="#сортировка-ведер-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function bucketSort(items) { let buckets = new Array(items.length); for (let i = 0; i &#x3C; buckets.length; i++) { buckets[i] = []; } for (let j = 0; j &#x3C; items.length; j++) { let bucket = Math.floor(items[j] / items. length); buckets[bucket].push(items[j]); } for (let k = 0; k &#x3C; buckets.length; k++) { buckets[k].sort(); } return [].concat(...buckets); } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(bucketSort(items));</code></p>
<h2 id="shell-sort">Shell sort<a aria-hidden="true" tabindex="-1" href="#shell-sort"><span class="icon icon-link"></span></a></h2>
<p>Shell sort использует алгоритм сортировки вставкой, но вместо того, чтобы сортировать весь список сразу, список делится на меньшие подсписки. Эти подсписки затем сортируются с помощью алгоритма сортировки вставкой, что сокращает количество обменов, необходимых для сортировки списка.</p>
<p>Этот алгоритм также известен как ”метод Шелла”. Для его работы сначала определяется последовательность целых чисел, называемая последовательностью приращения. Последовательность инкремента используется для определения размера подсписков, которые будут сортироваться независимо друг от друга. Наиболее часто используемая последовательность инкрементов - это “последовательность Кнута”, которая определяется следующим образом (где <code>$h$</code> - интервал с начальным значением, а $n$ - длина списка):</p>
<p><code>h = 1, пока h &#x3C; n: h = 3*h + 1</code>.</p>
<p>После определения последовательности инкрементов алгоритм сортировки Shell переходит к сортировке подсписков элементов. Вложенные списки сортируются с помощью алгоритма сортировки вставкой, а в качестве размера шага используется последовательность приращений. Алгоритм сортирует вложенные списки, начиная с наибольшего приращения и затем итерируя вниз к наименьшему приращению.</p>
<p>Алгоритм останавливается, когда размер инкремента становится равным <code>1</code>, после чего он эквивалентен обычному алгоритму сортировки вставками.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851917sorting_shellsort.Dgx_DxQn_1a2X7G.webp" alt="1680851917sorting_shellsort.gif" width="277" height="344" loading="lazy" decoding="async"><figcaption>1680851917sorting_shellsort.gif</figcaption></figure>
<p>Сортировка Shell была изобретена Дональдом Шеллом в 1959 году как разновидность сортировки вставкой, которая стремится улучшить свою производительность за счет разбиения исходного списка на более мелкие подсписки и независимой сортировки этих подсписков.</p>
<h3 id="преимущества-сортировки-по-оболочке">Преимущества сортировки по оболочке<a aria-hidden="true" tabindex="-1" href="#преимущества-сортировки-по-оболочке"><span class="icon icon-link"></span></a></h3>
<p>Это обобщение сортировки вставками, поэтому его легко понять и реализовать. Его временная сложность лучше, чем <code>$O(n^2)$</code> для многих последовательностей входных данных. Это алгоритм сортировки на месте, что означает, что он не требует дополнительной памяти.</p>
<h3 id="недостатки-shell-sort">Недостатки shell sort<a aria-hidden="true" tabindex="-1" href="#недостатки-shell-sort"><span class="icon icon-link"></span></a></h3>
<p>Сложно предсказать временную сложность сортировки shell, так как она зависит от выбора последовательности инкрементов.</p>
<h3 id="использование-sases-для-shell-sort">Использование sases для shell sort<a aria-hidden="true" tabindex="-1" href="#использование-sases-для-shell-sort"><span class="icon icon-link"></span></a></h3>
<p>Shell sort - это алгоритм общего назначения для сортировки данных в различных приложениях, особенно при сортировке больших наборов данных, как в quicksort и bucket sort.</p>
<p>Сортировка в основном отсортированных данных. Shell sort сокращает количество сравнений и обменов, необходимых для сортировки данных. Это делает ее быстрее других алгоритмов сортировки, таких как quicksort или merge sort, в данном конкретном сценарии.</p>
<p>Сортировка массивов с небольшим количеством инверсий. Инверсия - это показатель того, насколько несортированным является массив, и определяется как количество пар элементов, расположенных в неправильном порядке. Shell sort эффективнее некоторых других алгоритмов, таких как пузырьковая сортировка или сортировка вставкой, при сортировке массивов с небольшим числом инверсий.</p>
<p>Сортировка на месте. Shell sort не требует дополнительной памяти для сортировки входных данных, что делает его претендентом на место сортировки. Это делает ее полезной в ситуациях, когда память ограничена или когда дополнительное использование памяти нежелательно.</p>
<p>Сортировка в распределенной среде. Разбивая входные данные на более мелкие подсписки и сортируя их независимо друг от друга, каждый подсписок можно сортировать на отдельном процессоре или узле, что сокращает время, необходимое для сортировки данных.</p>
<h3 id="реализация-сортировки-в-оболочке">Реализация сортировки в оболочке<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-в-оболочке"><span class="icon icon-link"></span></a></h3>
<p>Разделить список элементов на ”ведра” на основе некоторых критериев Сортировать каждое ведро по отдельности Объединить отсортированные ведра</p>
<h3 id="реализация-сортировки-в-оболочке-на-языке-python">Реализация сортировки в оболочке на языке Python<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-в-оболочке-на-языке-python"><span class="icon icon-link"></span></a></h3>
<p><code>def shell_sort(items): sublistcount = len(items)//2 while sublistcount > 0: for start in range(sublistcount): gap_insertion_sort(items, start, sublistcount) sublistcount = sublistcount // 2 return items def gap_insertion_sort(items, start, gap): for i in range(start+gap, len(items), gap): currentvalue = items[i] position = i while position >= gap и items[position-gap] > currentvalue: items[position] = items[position-gap] position = position-gap items[position] = currentvalue items = [6,20,8,19,56,23,87,41,49,53] print(shell_sort(items))</code>.</p>
<h3 id="реализация-сортировки-в-javascript">Реализация сортировки в JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function shellSort(items) { let sublistcount = Math.floor(items.length / 2); while (sublistcount > 0) { for (let start = 0; start &#x3C; sublistcount; start++) { gapInsertionSort(items, start, sublistcount); } sublistcount = Math.floor(sublistcount / 2); } return items; } function gapInsertionSort(items, start, gap) { for (let i = start + gap; i &#x3C; items. length; i += gap) { let currentValue = items[i]; let position = i; while (position >= gap &#x26;&#x26; items[position - gap] > currentValue) { items[position] = items[position - gap]; position = position - gap; } items[position] = currentValue; } } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(shellSort(items));</code></p>
<h2 id="сортировка-слиянием">Сортировка слиянием<a aria-hidden="true" tabindex="-1" href="#сортировка-слиянием"><span class="icon icon-link"></span></a></h2>
<p>Основная идея сортировки слиянием заключается в том, чтобы разделить входной список пополам, рекурсивно отсортировать каждую половину с помощью сортировки слиянием, а затем объединить две отсортированные половины вместе. Шаг слияния выполняется путем многократного сравнения первого элемента каждой половины и добавления меньшего из них к отсортированному списку. Этот процесс повторяется до тех пор, пока все элементы не будут объединены вместе.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851758merge-sort-example.BmbLhvwc_Z2hm9Wq.webp" alt="1680851758merge-sort-example.gif" width="300" height="180" loading="lazy" decoding="async"><figcaption>1680851758merge-sort-example.gif</figcaption></figure>
<p>Временная сложность сортировки слиянием составляет <code>$O(n log n)$</code> в наихудшем случае, что делает ее более эффективной, чем другие популярные алгоритмы сортировки, такие как пузырьковая сортировка, сортировка вставкой или сортировка выбором.</p>
<p>Сортировка слиянием также является алгоритмом, что означает, что она сохраняет относительный порядок одинаковых элементов.</p>
<h3 id="недостатки-сортировки-слиянием">Недостатки сортировки слиянием<a aria-hidden="true" tabindex="-1" href="#недостатки-сортировки-слиянием"><span class="icon icon-link"></span></a></h3>
<p>У сортировки слиянием есть некоторые недостатки, когда речь идет об использовании памяти. Алгоритм требует дополнительной памяти для хранения двух половин списка на этапе разделения, а также дополнительной памяти для хранения окончательного отсортированного списка на этапе слияния. Это может быть проблемой при сортировке очень больших списков.</p>
<h3 id="история-сортировки-слиянием">История сортировки слиянием<a aria-hidden="true" tabindex="-1" href="#история-сортировки-слиянием"><span class="icon icon-link"></span></a></h3>
<p>Сортировка слиянием была изобретена Джоном фон Нейманом в 1945 году как алгоритм сортировки на основе сравнения, который работает путем разделения входного списка на более мелкие подсписки, рекурсивной сортировки этих подсписков, а затем объединения их вместе для получения конечного отсортированного списка.</p>
<h3 id="примеры-использования-сортировки-слиянием">Примеры использования сортировки слиянием<a aria-hidden="true" tabindex="-1" href="#примеры-использования-сортировки-слиянием"><span class="icon icon-link"></span></a></h3>
<p>Merge sort - это алгоритм сортировки общего назначения, который может быть распараллелен для сортировки больших наборов данных и внешней сортировки (а-ля quicksort и bucket sort), а также часто используется в качестве строительного блока для более сложных алгоритмов (таких как bubble sort и insertion sort).</p>
<p>Стабильная сортировка. Стабильная сортировка для сортировки слиянием означает, что она сохраняет относительный порядок одинаковых элементов. Это делает ее полезной в ситуациях, когда сохранение порядка равных элементов важно, например в финансовых приложениях или при сортировке данных для целей визуализации.</p>
<p>Реализация бинарного поиска. Он используется для эффективного поиска определенного элемента в отсортированном списке, поскольку опирается на отсортированный вход. Слияние сортировок может использоваться для эффективной сортировки входных данных для двоичного поиска и других подобных алгоритмов.</p>
<h3 id="реализация-сортировки-слиянием">Реализация сортировки слиянием<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-слиянием"><span class="icon icon-link"></span></a></h3>
<p>Использование рекурсии для разбиения списка на меньшие отсортированные подсписки Слияние подсписков обратно вместе, сравнение и сортировка элементов по мере их объединения</p>
<h3 id="реализация-сортировки-слиянием-в-python">Реализация сортировки слиянием в Python<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-слиянием-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def merge_sort(items): if len(items) &#x3C;= 1: return items mid = len(items) // 2 left = items[:mid] right = items[mid:] left = merge_sort(left) right = merge_sort(right) return merge(left, right) def merge(left, right): merged = [] left_index = 0 right_index = 0 while left_index &#x3C; len(left) and right_index &#x3C; len(right): if left[left_index] > right[right_index]: merged. append(right[right_index]) right_index += 1 else: merged.append(left[left_index]) left_index += 1 merged += left[left_index:] merged += right[right_index:] return merged items = [6,20,8,19,56,23,87,41,49,53] print(merge_sort(items))</code></p>
<h3 id="реализация-сортировки-слиянием-на-javascript">Реализация сортировки слиянием на JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-слиянием-на-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function mergeSort(items) { if (items.length &#x3C;= 1) { return items; } let mid = Math.floor(items.length / 2); let left = items.slice(0, mid); let right = items.slice(mid); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { let merged = []; let leftIndex = 0; let rightIndex = 0; while (leftIndex &#x3C; left. length &#x26;&#x26; rightIndex &#x3C; right.length) { if (left[leftIndex] > right[rightIndex]) { merged.push(right[rightIndex]); rightIndex++; } else { merged.push(left[leftIndex]); leftIndex++; } } return merged.concat(left.slice(leftIndex)).concat(right.slice(rightIndex)); } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(mergeSort(items));</code></p>
<h2 id="сортировка-по-выбору">Сортировка по выбору<a aria-hidden="true" tabindex="-1" href="#сортировка-по-выбору"><span class="icon icon-link"></span></a></h2>
<p>Сортировка по выбору многократно выбирает наименьший элемент из неотсортированной части списка и меняет его местами с первым элементом неотсортированной части. Этот процесс продолжается до тех пор, пока весь список не будет отсортирован.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851759selection-sort-animation.XpXt9h4D_MCwB0.webp" alt="1680851759selection-sort-animation.gif" width="100" height="371" loading="lazy" decoding="async"><figcaption>1680851759selection-sort-animation.gif</figcaption></figure>
<p>Красный - текущий мин, желтый - отсортированный список, синий - текущий элемент. : Wikimedia Commons, CC BY-SA 3.0. История сортировки по выбору</p>
<p>Selection sort - это простой и интуитивно понятный алгоритм сортировки, который появился еще на заре компьютерной науки. Вполне вероятно, что подобные алгоритмы были разработаны исследователями независимо друг от друга в 1950-х годах.</p>
<p>Это был один из первых разработанных алгоритмов сортировки, и он остается популярным алгоритмом для образовательных целей и для решения простых задач сортировки.</p>
<h3 id="преимущества-сортировки-по-выбору">Преимущества сортировки по выбору<a aria-hidden="true" tabindex="-1" href="#преимущества-сортировки-по-выбору"><span class="icon icon-link"></span></a></h3>
<p>Сортировка по выбору используется в некоторых приложениях, где простота и легкость реализации важнее эффективности. Она также полезна в качестве учебного инструмента для ознакомления студентов с алгоритмами сортировки и их свойствами, поскольку ее легко понять и реализовать.</p>
<h3 id="недостатки-сортировки-по-выбору">Недостатки сортировки по выбору<a aria-hidden="true" tabindex="-1" href="#недостатки-сортировки-по-выбору"><span class="icon icon-link"></span></a></h3>
<p>Несмотря на свою простоту, selection sort не очень эффективен по сравнению с другими алгоритмами сортировки, такими как merge sort или quicksort. Ее наихудшая временная сложность составляет <code>$O(n^2)$</code>, и сортировка больших списков может занять много времени.</p>
<p>Selection sort также не является стабильным алгоритмом сортировки, то есть он может не сохранять порядок одинаковых элементов.</p>
<h3 id="примеры-использования-сортировки-по-выбору">Примеры использования сортировки по выбору<a aria-hidden="true" tabindex="-1" href="#примеры-использования-сортировки-по-выбору"><span class="icon icon-link"></span></a></h3>
<p>Selection sort похож на bubble sort и insertion sort тем, что может использоваться для сортировки небольших наборов данных, а его простота также делает его полезным инструментом для обучения и изучения алгоритмов сортировки. Другие варианты использования::</p>
<p>Сортировка данных при ограниченном объеме памяти. Для выполнения сортировки требуется лишь постоянный объем дополнительной памяти, что делает ее полезной в ситуациях, когда использование памяти ограничено.</p>
<p>Сортировка данных с уникальными значениями. Сортировка не зависит от исходных данных, которые в основном сортируются, что делает ее хорошим выбором для наборов данных с уникальными значениями, где другие алгоритмы сортировки могут потребовать дополнительных проверок или оптимизаций.</p>
<h3 id="реализация-сортировки-по-выбору">Реализация сортировки по выбору<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-по-выбору"><span class="icon icon-link"></span></a></h3>
<p>Итерация по списку с выбором самого нижнего элемента Замена самого нижнего элемента элементом, находящимся на текущей позиции Повторите процесс для остальной части списка</p>
<h3 id="реализация-сортировки-по-выбору-в-python">Реализация сортировки по выбору в Python<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-по-выбору-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def selection_sort(items): for i in range(len(items)): min_idx = i for j in range(i+1, len(items)): if items[min_idx] > items[j]: min_idx = j items[i], items[min_idx] = items[min_idx], items[i] return items items = [6,20,8,19,56,23,87,41,49,53] print(selection_sort(items))</code></p>
<h3 id="реализация-сортировки-по-выбору-в-javascript">Реализация сортировки по выбору в JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-сортировки-по-выбору-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function selectionSort(items) { let minIdx; for (let i = 0; i &#x3C; items.length; i++) { minIdx = i; for (let j = i + 1; j &#x3C; items.length; j++) { if (items[j] &#x3C; items[minIdx]) { minIdx = j; } } let temp = items[i]; items[i] = items[minIdx]; items[minIdx] = temp; } return items; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(selectionSort(items));</code></p>
<h2 id="радиксная-сортировка">Радиксная сортировка<a aria-hidden="true" tabindex="-1" href="#радиксная-сортировка"><span class="icon icon-link"></span></a></h2>
<p>Основная идея радиксной сортировки заключается в том, чтобы сортировать данные, группируя их по каждой цифре в сортируемых числах или символах справа налево или слева направо. Этот процесс повторяется для каждой цифры, в результате чего получается отсортированный список.</p>
<p>Его наихудшая производительность составляет <code>${O(wcdot n)}$</code>, где <code>$n$</code> - количество ключей, а <code>$w$</code> - длина ключа.</p>
<h3 id="история-радиксной-сортировки">История радиксной сортировки<a aria-hidden="true" tabindex="-1" href="#история-радиксной-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Радиксная сортировка была впервые представлена Германом Холлеритом в конце XIX века как способ эффективной сортировки данных на перфокартах, где каждый столбец представлял цифру в данных.</p>
<p>Позже она была адаптирована и популяризирована несколькими исследователями в середине XX века для сортировки двоичных данных путем группировки данных по каждому биту в двоичном представлении. Но она также используется для сортировки строковых данных, где каждый символ рассматривается как цифра в сортировке.</p>
<p>В последние годы к радиксной сортировке возродился интерес как к алгоритму сортировки для параллельных и распределенных вычислительных сред, поскольку она легко распараллеливается и может использоваться для распределенной сортировки больших наборов данных.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680852008radix-sort.BkafeU-S_Z11B8YK.webp" alt="1680852008radix-sort.jpg" width="800" height="640" loading="lazy" decoding="async"><figcaption>1680852008radix-sort.jpg</figcaption></figure>
<p>Карточный сортировщик IBM, выполняющий радиксную сортировку на большом наборе перфокарт. : Wikimedia Commons, Public Domain. Преимущества радиксной сортировки</p>
<p>Радиксная сортировка - это алгоритм сортировки с линейным временем, то есть ее временная сложность пропорциональна размеру входных данных. Это делает его эффективным алгоритмом для сортировки больших наборов данных, хотя он может быть не так эффективен, как другие алгоритмы сортировки для меньших наборов данных.</p>
<p>Линейная сложность и стабильность делают его полезным инструментом для сортировки больших наборов данных, а его распараллеливаемость (да, это реальное слово) делает его полезным для сортировки данных в распределенных вычислительных средах.</p>
<p>Radix sort также является стабильным алгоритмом сортировки, то есть он сохраняет относительный порядок равных элементов.</p>
<h3 id="случаи-использования-радиксной-сортировки">Случаи использования радиксной сортировки<a aria-hidden="true" tabindex="-1" href="#случаи-использования-радиксной-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Радиксная сортировка может использоваться в различных приложениях, где требуется эффективная сортировка больших наборов данных. Она особенно полезна для сортировки строковых данных и ключей фиксированной длины, а также может использоваться в параллельных и распределенных вычислительных средах.</p>
<p>Параллельная обработка. Radix sort часто предпочтительнее для сортировки больших наборов данных (чем merge sort, quicksort и bucket sort). Как и bucket sort, radix может эффективно сортировать строковые данные, что делает ее подходящей для приложений обработки естественного языка.</p>
<p>Сортировка данных с ключами фиксированной длины. Radix sort особенно эффективна при сортировке данных с ключами фиксированной длины, поскольку она может выполнять сортировку, исследуя каждый ключ по одной цифре за раз.</p>
<h3 id="реализация-radix-sort">Реализация Radix sort<a aria-hidden="true" tabindex="-1" href="#реализация-radix-sort"><span class="icon icon-link"></span></a></h3>
<p>Сравните цифры каждого элемента в списке. Сгруппируйте элементы в соответствии с цифрами. Отсортировать группы по размеру. Рекурсивно отсортируйте каждую группу, пока каждый элемент не окажется на своем месте.</p>
<h3 id="реализация-радиксной-сортировки-в-python">Реализация радиксной сортировки в Python<a aria-hidden="true" tabindex="-1" href="#реализация-радиксной-сортировки-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def radix_sort(items): max_length = False tmp, placement = -1, 1 while not max_length: max_length = True buckets = [list() for _ in range(10)] for i in items: tmp = i // placement buckets[tmp % 10]. append(i) if max_length and tmp > 0: max_length = False a = 0 for b in range(10): buck = buckets[b] for i in buck: items[a] = i a += 1 placement *= 10 return items items = [6,20,8,19,56,23,87,41,49,53] print(radix_sort(items))</code></p>
<h3 id="реализация-радиксной-сортировки-в-javascript">Реализация радиксной сортировки в JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-радиксной-сортировки-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function radixSort(items) { let maxLength = false; let tmp = -1; let placement = 1; while (!maxLength) { maxLength = true; let buckets = Array. from({ length: 10 }, () => []); for (let i = 0; i &#x3C; items.length; i++) { tmp = Math.floor(items[i] / placement); buckets[tmp % 10].push(items[i]); if (maxLength &#x26;&#x26; tmp > 0) { maxLength = false; } } let a = 0; for (let b = 0; b &#x3C; 10; b++) { let buck = buckets[b]; for (let j = 0; j &#x3C; buck.length; j++) { items[a] = buck[j]; a++; } } placement *= 10; } return items; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(radixSort(items));</code></p>
<h2 id="комбинированная-сортировка">Комбинированная сортировка<a aria-hidden="true" tabindex="-1" href="#комбинированная-сортировка"><span class="icon icon-link"></span></a></h2>
<p>Comb sort сравнивает пары элементов, находящихся на определенном расстоянии друг от друга, и меняет их местами, если они идут не по порядку. Расстояние между парами первоначально устанавливается равным размеру сортируемого списка, а затем уменьшается на коэффициент (называемый ”коэффициентом уменьшения”) с каждым проходом, пока не достигнет минимального значения <code>$1$</code>. Этот процесс повторяется до тех пор, пока список не будет полностью отсортирован.</p>
<p>Алгоритм гребенчатой сортировки похож на алгоритм пузырьковой сортировки, но с большим промежутком между сравниваемыми элементами. Этот больший промежуток позволяет большим значениям быстрее занять нужную позицию в списке.</p>
<figure class="igorlov-figure"><img  src="/_astro/1680851753comb_sort_demo.CAhFicQJ_Z1AWsNc.webp" alt="1680851753comb_sort_demo.gif" width="269" height="257" loading="lazy" decoding="async"><figcaption>1680851753comb_sort_demo.gif</figcaption></figure>
<p>Алгоритм comb sort - это относительно недавний алгоритм сортировки, который впервые был представлен в 1980 году Влодзимежем Добосевичем и Артуром Боровым. Алгоритм был вдохновлен идеей использования расчески для распрямления спутанных волос, и он использует аналогичный процесс для распрямления списка неотсортированных значений.</p>
<h3 id="преимущества-гребневой-сортировки">Преимущества гребневой сортировки<a aria-hidden="true" tabindex="-1" href="#преимущества-гребневой-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Comb sort имеет наихудшую временную сложность <code>$O(n^2)$</code>, но на практике она часто быстрее, чем другие алгоритмы сортировки <code>$O(n^2)$</code>, такие как bubble sort, благодаря использованию коэффициента сжатия. Коэффициент усадки позволяет алгоритму быстро перемещать большие значения к их правильной позиции, сокращая количество проходов, необходимых для полной сортировки списка.</p>
<h3 id="примеры-использования-гребенчатой-сортировки">Примеры использования гребенчатой сортировки<a aria-hidden="true" tabindex="-1" href="#примеры-использования-гребенчатой-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Comb sort - это относительно простой и эффективный алгоритм сортировки, который имеет несколько вариантов использования в различных приложениях.</p>
<p>Сортировка данных с большим диапазоном значений. Использование большего промежутка между сравниваемыми элементами позволяет большим значениям быстрее занять нужную позицию в списке.</p>
<p>Сортировка данных в приложениях реального времени. Будучи стабильным алгоритмом сортировки, гребенчатая сортировка сохраняет относительный порядок равных элементов. Это делает его полезным для сортировки данных в приложениях реального времени, где необходимо сохранять порядок равных элементов.</p>
<p>Сортировка данных в средах с ограниченным объемом памяти. Комбинированная сортировка не требует дополнительной памяти для сортировки данных. Это делает ее полезной для сортировки данных в средах с ограниченным объемом памяти, где дополнительная память недоступна.</p>
<h3 id="реализация-комбинированной-сортировки">Реализация комбинированной сортировки<a aria-hidden="true" tabindex="-1" href="#реализация-комбинированной-сортировки"><span class="icon icon-link"></span></a></h3>
<p>Начните с большого промежутка между элементами. Сравните элементы на концах промежутка и поменяйте их местами, если они расположены в неправильном порядке. Уменьшите зазор и повторяйте процесс, пока зазор не станет равным <code>1</code>. Завершите сортировку оставшихся элементов с помощью пузырьковой сортировки.</p>
<h3 id="реализация-комбинированной-сортировки-в-python">Реализация комбинированной сортировки в Python<a aria-hidden="true" tabindex="-1" href="#реализация-комбинированной-сортировки-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def comb_sort(items): gap = len(items) shrink = 1. 3 sorted = False while not sorted: gap //= shrink if gap &#x3C;= 1: sorted = True else: for i in range(len(items)-gap): if items[i] > items[i+gap]: items[i],items[i+gap] = items[i+gap],items[i] return bubble_sort(items) def bubble_sort(items): for i in range(len(items)): for j in range(len(items)-1-i): if items[j] > items[j+1]: items[j], items[j+1] = items[j+1], items[j] return items items = [6,20,8,19,56,23,87,41,49,53] print(comb_sort(items))</code>.</p>
<h3 id="реализация-комбинированной-сортировки-на-javascript">Реализация комбинированной сортировки на JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-комбинированной-сортировки-на-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function combSort(items) { let gap = items.length; let shrink = 1.3; let sorted = false; while (!sorted) { gap = Math.floor(gap / shrink); if (gap &#x3C;= 1) { sorted = true; } else { for (let i = 0; i &#x3C; items.length - gap; i++) { if (items[i] > items[i + gap]) { let temp = items[i]; items[i] = items[i + gap]; items[i + gap] = temp; } } } } return bubbleSort(items); } function bubbleSort(items) { let swapped; do { swapped = false; for (let i = 0; i &#x3C; items.length - 1; i++) { if (items[i] > items[i + 1]) { let temp = items[i]; items[i] = items[i + 1]; items[i + 1] = temp; swapped = true; } } } while (swapped); return items; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(combSort(items));</code></p>
<h2 id="timsort">Timsort<a aria-hidden="true" tabindex="-1" href="#timsort"><span class="icon icon-link"></span></a></h2>
<p>Алгоритм Timsort работает путем разделения входных данных на более мелкие подмассивы, а затем использует сортировку вставкой для сортировки этих подмассивов. Затем эти отсортированные подмассивы объединяются с помощью сортировки слиянием, чтобы получить полностью отсортированный массив.</p>
<p>Timsort имеет наихудшую временную сложность <code>$O(n log n)$</code>, что делает его эффективным для сортировки больших наборов данных. Это также стабильный алгоритм сортировки, то есть он сохраняет относительный порядок одинаковых элементов.</p>
<h3 id="преимущества-timsort">Преимущества Timsort<a aria-hidden="true" tabindex="-1" href="#преимущества-timsort"><span class="icon icon-link"></span></a></h3>
<p>Одной из ключевых особенностей Timsort является его способность эффективно обрабатывать различные типы данных. Для этого он обнаруживает ”прогоны” - последовательности элементов, которые уже отсортированы. Затем Timsort объединяет эти прогоны таким образом, чтобы минимизировать количество сравнений и замен, необходимых для получения полностью отсортированного массива.</p>
<p>Еще одна важная особенность Timsort - способность работать с частично отсортированными данными. В этом случае Timsort может обнаружить частично отсортированные области и использовать сортировку вставкой для их быстрой сортировки, сокращая время, необходимое для полной сортировки данных.</p>
<h3 id="история-timsort">История Timsort<a aria-hidden="true" tabindex="-1" href="#история-timsort"><span class="icon icon-link"></span></a></h3>
<p>Timsort был разработан Тимом Питерсом в 2002 году для использования в языке программирования Python. Это гибридный алгоритм сортировки, использующий комбинацию методов сортировки вставкой и сортировки слиянием, и предназначенный для эффективной сортировки различных типов данных.</p>
<p>Благодаря своей эффективности и универсальности в работе с различными типами данных, он был принят в ряде других языков программирования, включая Java и C#.</p>
<h3 id="примеры-использования-timsort">Примеры использования Timsort<a aria-hidden="true" tabindex="-1" href="#примеры-использования-timsort"><span class="icon icon-link"></span></a></h3>
<p>Как продвинутый алгоритм, Timsort может использоваться при сортировке данных на системах с ограниченным объемом памяти.</p>
<p>Сортировка в языках программирования. Timsort часто используется в качестве алгоритма сортировки по умолчанию в этих языках благодаря своей эффективности и способности работать с различными типами данных.</p>
<p>Сортировка реальных данных. Timsort особенно эффективен при сортировке реальных данных, которые могут быть частично отсортированы или содержать уже отсортированные подмассивы, поскольку он способен обнаружить эти пробеги и использовать сортировку вставкой для их быстрой сортировки, сокращая время, необходимое для полной сортировки данных.</p>
<p>Сортировка данных различных типов. Сортировка предназначена для эффективной работы с различными типами данных, включая числа, строки и пользовательские объекты. Он может обнаружить прогоны данных с одинаковым типом и эффективно объединить их с помощью сортировки слиянием, сократив количество необходимых сравнений и обменов.</p>
<h3 id="реализация-timsort">Реализация Timsort<a aria-hidden="true" tabindex="-1" href="#реализация-timsort"><span class="icon icon-link"></span></a></h3>
<p>Возьмите несортированный список и разбейте его на меньшие отсортированные подсписки. Объедините подсписки, чтобы сформировать больший отсортированный список. Повторяйте процесс, пока весь список не будет отсортирован.</p>
<h3 id="реализация-timsort-в-python">Реализация Timsort в Python<a aria-hidden="true" tabindex="-1" href="#реализация-timsort-в-python"><span class="icon icon-link"></span></a></h3>
<p><code>def insertion_sort(arr, left=0, right=None): if right is None: right = len(arr) - 1 for i in range(left + 1, right + 1): key_item = arr[i] j = i - 1 while j >= left and arr[j] > key_item: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key_item return arr def merge(left, right): if not left: return right if not right: return left if left[0] &#x3C; right[0]: return [left[0]] + merge(left[1:], right) return [right[0]] + merge(left, right[1:]) def timsort(arr): min_run = 32 n = len(arr) for i in range(0, n, min_run): insertion_sort(arr, i, min((i + min_run - 1), n - 1)) size = min_run while size &#x3C; n: for start in range(0, n, size * 2): midpoint = start + size - 1 end = min((start + size * 2 - 1), (n-1)) merged_array = merge( left=arr[start:midpoint + 1], right=arr[midpoint + 1:end + 1] ) arr[start:start + len(merged_array)] = merged_array size *= 2 return arr items = [6,20,8,19,56,23,87,41,49,53] print(timsort(items))</code></p>
<h3 id="реализация-timsort-в-javascript">Реализация Timsort в JavaScript<a aria-hidden="true" tabindex="-1" href="#реализация-timsort-в-javascript"><span class="icon icon-link"></span></a></h3>
<p><code>function insertionSort(arr, left = 0, right = arr. length - 1) { for (let i = left + 1; i &#x3C;= right; i++) { const keyItem = arr[i]; let j = i - 1; while (j >= left &#x26;&#x26; arr[j] > keyItem) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = keyItem; } return arr; } function merge(left, right) { let i = 0; let j = 0; const merged = []; while (i &#x3C; left. length &#x26;&#x26; j &#x3C; right.length) { if (left[i] &#x3C; right[j]) { merged.push(left[i]); i++; } else { merged.push(right[j]); j++; } } return merged.concat(left.slice(i)).concat(right.slice(j)); } function timsort(arr) { const minRun = 32; const n = arr.length; for (let i = 0; i &#x3C; n; i += minRun) { insertionSort(arr, i, Math. min(i + minRun - 1, n - 1)); } let size = minRun; while (size &#x3C; n) { for (let start = 0; start &#x3C; n; start += size * 2) { const midpoint = start + size - 1; const end = Math. min(start + size * 2 - 1, n - 1); const merged = merge( arr.slice(start, midpoint + 1), arr.slice(midpoint + 1, end + 1) ); arr.splice(start, merged.length, ...merged); } size *= 2; } return arr; } let items = [6, 20, 8, 19, 56, 23, 87, 41, 49, 53]; console.log(timsort(items));</code></p>
<h2 id="сравнение-всех-алгоритмов-сортировки">Сравнение всех алгоритмов сортировки<a aria-hidden="true" tabindex="-1" href="#сравнение-всех-алгоритмов-сортировки"><span class="icon icon-link"></span></a></h2>
<p>Обратите внимание, что временная сложность и пространственная сложность, указанные в таблице, являются наихудшими, а реальная производительность может отличаться в зависимости от конкретной реализации и входных данных.</p>
<h2 id="какой-самый-распространенный-алгоритм-сортировки">Какой самый распространенный алгоритм сортировки?<a aria-hidden="true" tabindex="-1" href="#какой-самый-распространенный-алгоритм-сортировки"><span class="icon icon-link"></span></a></h2>
<p>Наиболее распространенным алгоритмом сортировки, вероятно, является quicksort. Он широко используется во многих языках программирования, включая C, C++, Java и Python, а также во многих программных приложениях и библиотеках. Quicksort предпочитают за его эффективность и универсальность в работе с различными типами данных, и он часто используется в качестве алгоритма сортировки по умолчанию в языках программирования и программных фреймворках.</p>
<p>Однако другие алгоритмы сортировки, такие как merge sort и Timsort, также широко используются в различных приложениях благодаря своей эффективности и уникальным возможностям.</p>
<h2 id="заключительные-мысли">Заключительные мысли<a aria-hidden="true" tabindex="-1" href="#заключительные-мысли"><span class="icon icon-link"></span></a></h2>
<p>Знание основ алгоритмов сортировки необходимо всем, кто интересуется программированием, анализом данных или компьютерными науками. Понимая различные алгоритмы сортировки и их характеристики, вы сможете улучшить свою способность выбирать и реализовывать наилучший алгоритм для конкретного случая использования.</p>
<p>Выбор оптимального алгоритма сортировки зависит от нескольких факторов, включая размер входных данных, их распределение, объем доступной памяти и желаемую временную сложность.</p>
<p>Алгоритмы сортировки можно разделить на категории по временной сложности, пространственной сложности, сортировке на месте, стабильной сортировке и адаптивной сортировке. Важно понимать характеристики и компромиссы различных алгоритмов сортировки, чтобы выбрать наиболее подходящий алгоритм для конкретного случая использования.</p>
<p><a href="https://www.sitepoint.com/best-sorting-algorithms/?utm_source=rss" rel="noopener noreferrer nofollow" target="_blank">Источник</a></p> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=10 лучших алгоритмов сортировки с примерами&#38;url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy&#38;title=10 лучших алгоритмов сортировки с примерами&#38;summary=Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/10-luchshykh-alhorytmov-sortyrovky-s-prymeramy&#38;media=&#38;description=Алгоритмы сортировки являются фундаментальной частью компьютерной науки и имеют множество применений, начиная от сортировки данных в базах данных и заканчивая" target="_blank" rel="noreferrer noopener nofollow" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <nav class="circular-pagination" aria-label="Circular Pagination" data-astro-cid-ihkjvfsn> <a href="/blog/10-nezamenym-kh-hemmov-dlia-prylozhenyi-na-ruby-on-rails" class="circular-pagination__link circular-pagination__link--prev" data-astro-cid-ihkjvfsn> 10 незаменимых геммов для приложений на Ruby on Rails </a> <a href="/blog/01-benchmark-chet-rekh-b-kendov-jit" class="circular-pagination__link circular-pagination__link--next" data-astro-cid-ihkjvfsn> #01 Бенчмарк четырех бэкендов JIT </a> </nav>  </div> </article> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><astro-island uid="Z1T5Wnr" prefix="r0" component-url="/_astro/YandexRelatedAds.svLg6TOn.js" component-export="default" renderer-url="/_astro/client.D9Vng9vH.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;YandexRelatedAds&quot;,&quot;value&quot;:true}" await-children=""><div id="yandex_rtb_C-A-2592503-2"></div><!--astro:end--></astro-island> <astro-island uid="Z2a8j9B" component-url="/_astro/CommentBlock.BwogX8bT.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;CommentBlock&quot;,&quot;value&quot;:true}"></astro-island>  </div> <!-- <div class="blocks__container container">
			<CtaBlock id="cta" class=""
			/>
		</div> --> </div>    </main> <footer class="footer" data-astro-cid-dwelrhxs> <div class="footer__container container" data-astro-cid-dwelrhxs> <a href="/" class="logo font-extrabold lowercase transition-colors fluid:text-lg footer__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>Фул фронт дев</a>  <small class="footer__copyright" data-astro-cid-dwelrhxs>все права защищены. © 2024</small> </div> </footer>  </body></html>