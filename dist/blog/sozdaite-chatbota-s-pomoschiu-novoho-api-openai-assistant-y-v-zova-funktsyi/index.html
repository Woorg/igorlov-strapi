<!DOCTYPE html><html lang="ru"> <head><title>Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций | Игорь Горлов - Фронтeндер</title><link rel="canonical" href="https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi"><meta name="description" content="Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога O"><meta name="robots" content="index, follow"><!-- favicon --><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><!-- theme meta --><meta name="theme-name" content="igorlov.ru"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="generator" content="Astro v4.5.1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- responsive meta --><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><meta name="google-adsense-account" content="ca-pub-0634695143666394"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ViewTransitions.astro_astro_type_script_index_0_lang.DqfSmqP7.js"></script><link rel="stylesheet" href="/_astro/_regular_.Dd2YhbvP.css" />
<style>.breadcrumbs[data-astro-cid-vcbh62el]{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));border-radius:min(1.5rem,1.1625rem + .45vw);padding-left:min(2rem,1.2125rem + 1.05vw);padding-right:min(2rem,1.2125rem + 1.05vw);padding-top:1rem;padding-bottom:1rem}.breadcrumbs[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__list[data-astro-cid-vcbh62el]{display:flex;align-items:center;gap:.125rem}.breadcrumbs__link[data-astro-cid-vcbh62el]{border-radius:9999px;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover{--tw-bg-opacity: 1;background-color:#fce4e1;background-color:rgba(252,228,225,var(--tw-bg-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]{padding:.125rem .75rem}.breadcrumbs__link[data-astro-cid-vcbh62el]:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#6a6a6a;background-color:rgba(106,106,106,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.breadcrumbs__link[data-astro-cid-vcbh62el]:hover:where([class=dark],[class=dark] *){--tw-bg-opacity: 1;background-color:#8a8a93;background-color:rgba(138,138,147,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}
</style>
<link rel="stylesheet" href="/_astro/_single_.CyWP_2Jq.css" />
<style>.circular-pagination[data-astro-cid-ihkjvfsn]{display:flex;width:100%;flex-wrap:wrap;align-items:center;justify-content:center;overflow:hidden;border-top-width:1px;--tw-border-opacity: 1;border-color:#020202;border-color:rgba(2,2,2,var(--tw-border-opacity));margin-top:min(1.25rem,1.1375rem + .15vw)}.circular-pagination__link[data-astro-cid-ihkjvfsn]{width:100%;--tw-bg-opacity: 1;background-color:#fef9f8;background-color:rgba(254,249,248,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity));text-decoration-line:none}.circular-pagination__link[data-astro-cid-ihkjvfsn]:hover{--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.circular-pagination__link[data-astro-cid-ihkjvfsn]{padding-left:min(1.5rem,1.1625rem + .45vw);padding-right:min(1.5rem,1.1625rem + .45vw);padding-top:.5rem;padding-bottom:.5rem}
.theme-toggle[data-v-8d8d9c54]{width:1.25rem;height:1.25rem}
.comments[data-v-533071ec]{margin:auto;margin-top:1.25rem;max-width:42rem;--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.comments:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame[data-v-533071ec]{width:100%;--tw-bg-opacity: 1;background-color:#fff;background-color:rgba(255,255,255,var(--tw-bg-opacity));--tw-text-opacity: 1;color:#020202;color:rgba(2,2,2,var(--tw-text-opacity))}.giscus-frame:where([class=dark][data-v-533071ec],[class=dark] *[data-v-533071ec]){--tw-bg-opacity: 1;background-color:#131315;background-color:rgba(19,19,21,var(--tw-bg-opacity))}
</style><script type="module" src="/_astro/page.CFW0rSNk.js"></script><style>[data-astro-transition-scope="astro-vgmtzcrq-1"] { view-transition-name: blog-image-sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi; }</style></head> <body class="flex min-h-screen flex-col bg-gray-light pt-14 font-inter text-white fluid:text-lg dark:bg-black"> <header class="header" data-astro-cid-rq644orq> <div class="header__container container" data-astro-cid-rq644orq> <a href="/" class="logo font-extrabold lowercase transition-colors fluid:text-lg header__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>ФCВР</a>  <div class="nav header__nav" data-astro-cid-7wkmezxd> <button class="nav__open" title="Открыть меню" data-astro-cid-7wkmezxd> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> <span class="nav__open-line" data-astro-cid-7wkmezxd></span> </button> <nav class="nav__container" data-astro-cid-7wkmezxd> <button class="nav__close" title="Закрыть меню" data-astro-cid-7wkmezxd> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> <span class="nav__close-line" data-astro-cid-7wkmezxd></span> </button> <ul class="nav__list" data-astro-cid-7wkmezxd> <li class="nav__item" data-astro-cid-7wkmezxd> <a href="/projects" class="nav__link" data-astro-cid-7wkmezxd> Работы. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="/blog" class="nav__link nav__link--active" data-astro-cid-7wkmezxd> Блог. </a> </li><li class="nav__item" data-astro-cid-7wkmezxd> <a href="#cta" class="nav__link" data-astro-cid-7wkmezxd> Контакты. </a> </li> </ul> </nav> </div>  <script type="module">document.addEventListener("astro:page-load",()=>{const t=document.querySelector(".nav__open"),n=document.querySelector(".nav__close"),e=document.querySelector(".nav__container"),o=document.querySelectorAll(".nav__item");t?.addEventListener("click",()=>{e?.classList.toggle("nav__container--open"),e?.classList.toggle("fade-in-bottom")}),n?.addEventListener("click",()=>{e?.classList.toggle("nav__container--open"),e?.classList.toggle("fade-in-bottom")}),o.forEach(a=>{window.matchMedia("( max-width: 1024px)").matches&&a.addEventListener("click",()=>{e?.classList.toggle("nav__container--open"),e?.classList.toggle("fade-in-bottom")})})});</script> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();;(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();</script><astro-island uid="IJ3dh" component-url="/_astro/ThemeToggle.kpN4JrWQ.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-rq644orq&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;ThemeToggle&quot;,&quot;value&quot;:true}"></astro-island> </div> </header>  <main id="main-content" class="main flex-1">  <div class="blocks"> <div class="blocks__container container"> <nav aria-label="Breadcrumbs" class="breadcrumbs" data-astro-cid-vcbh62el> <ol class="breadcrumbs__list" role="list" data-astro-cid-vcbh62el> <li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/" data-astro-cid-vcbh62el> Главная </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el> <a class="breadcrumbs__link" href="/blog" data-astro-cid-vcbh62el> Blog </a> </li><li class="breadcrumbs__item" role="listitem" data-astro-cid-vcbh62el>  </li> </ol> </nav>  </div> <div class="blocks__container container"> <!-- <TextAds class="fade-in-bottom fluid:my-2" style="--delay: .8s;" /> --><article class="article" data-astro-cid-axzg2cw6> <div class="article__header" data-astro-cid-axzg2cw6> <ul class="article__categories categories" data-astro-cid-axzg2cw6> <li class="categories__item" data-astro-cid-axzg2cw6> <a href="/category/учебник" class="categories__link" data-astro-cid-axzg2cw6> Учебник  </a> </li> </ul> <h1 class="article__title text-wrap" data-astro-cid-axzg2cw6> Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций </h1> <ul class="article__tags tags" data-astro-cid-axzg2cw6> <li class="tags__item" data-astro-cid-axzg2cw6> <a class="tags__link" href="/tag/open-ai" data-astro-cid-axzg2cw6> Open AI </a> </li> </ul> <time class="article__date" data-astro-cid-axzg2cw6>
Опубликовано 18 дек., 2023 by Игорь Горлов </time> <time class="article__date" data-astro-cid-axzg2cw6> Последнее изменение: 21 мар., 2024 </time> </div>  <figure class="article__image" data-astro-cid-axzg2cw6> <picture> <source srcset="/_astro/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi-Dec-18-2023.BvYMuRcA_Z2hQHMd.avif" type="image/avif"><source srcset="/_astro/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi-Dec-18-2023.BvYMuRcA_1lkOUr.webp" type="image/webp"> <img src="/_astro/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi-Dec-18-2023.BvYMuRcA_227YGV.png" alt="Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций" class="aspect-auto h-full w-full object-cover object-center" loading="eager" data-astro-cid-axzg2cw6 data-astro-transition-scope="astro-vgmtzcrq-1" width="1200" height="500" decoding="async"> </picture> </figure>  <div class="article__content prose prose-zinc max-w-full dark:prose-invert prose-p:text-balance prose-a:no-underline hover:prose-a:underline prose-figure:-mx-12 prose-figure:w-screen prose-figure:bg-gray-light prose-figure:p-10 prose-figcaption:text-dark dark:prose-figure:bg-dark dark:prose-figcaption:text-white" data-astro-cid-axzg2cw6> <div id="adfox_17062261612859555"></div> <script>(function(){const blockId = "adfox_17062261612859555";

	window.yaContextCb = window.yaContextCb || [];
	window.yaContextCb.push(() => {
		Ya.adfoxCode.createAdaptive(
			{
				ownerId: 1493338,
				containerId: blockId,
				params: {
					p1: 'dawgg',
					p2: 'p',
				},
			},
			['desktop', 'tablet', 'phone'],
			{
				tabletWidth: 830,
				phoneWidth: 480,
				isAutoReloads: true,
			},
		);
	});
})();</script> <div class="article__meta" data-astro-cid-axzg2cw6> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций&#38;url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi&#38;title=Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций&#38;summary=Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога O&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi&#38;media=&#38;description=Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога O" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <a class="article__meta-section" href="#comments" data-astro-cid-axzg2cw6> Комментарии</a> </div> <details class="toc px-5 border border-gray-light lg:px-10 py-2 cursor-pointer"><summary class="title">Оглавление</summary><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#реализация">Реализация</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#api-ключ-openai-среда-nodejs">API-ключ OpenAI Среда Node.js</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#начнем-с-создания-помощника">Начнем с создания помощника.</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#наконец-мы-вызовем-функцию-main-чтобы-запустить-программу">Наконец, мы вызовем функцию main, чтобы запустить программу.</a></li></ol></details><p>Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога OpenAI, API Ассистента знаменует собой значительный шаг в расширении возможностей разработчиков по созданию агентоподобного опыта в своих приложениях.</p>
<p>По их собственным словам:</p>
<p>Сегодня мы выпускаем API Assistants - это наш первый шаг к тому, чтобы помочь разработчикам создавать агентоподобный опыт в своих приложениях. Ассистент - это специально созданный ИИ, который имеет конкретные инструкции, использует дополнительные знания и может вызывать модели и инструменты для выполнения задач.</p>
<p>Что же это значит для нас? По сути, это означает, что теперь у нас есть возможность создавать собственные ИИ-ассистенты с помощью API OpenAI. Это позволяет нам использовать возможности модели GPT-4 для выполнения задач и ответов на вопросы с помощью дополнительных знаний и контекста, которые мы предоставляем через загруженные документы (без необходимости привлечения сторонних разработчиков!), интерпретатор кода Python, работающий в изолированной среде, и функцию, которая действительно привлекла мое внимание: вызов функций.</p>
<p>Сами по себе функции не являются чем-то новым, но то, как они реализованы, действительно выделяется. Раньше вызов функции означал неуверенность в том, что модель вернется, и требовал постобработки для получения желаемого результата - и даже тогда успех не был гарантирован. Теперь мы можем указать желаемый выход функции, и модель будет стремиться предоставить ответ, соответствующий предоставленной схеме.</p>
<p>Этот новый инструмент дает нам огромную гибкость и мощь, позволяя нашему помощнику выполнять практически любые задачи - от отправки электронных писем до звонков и запросов к базам данных. Возможности безграничны.</p>
<p>Хотя доступных документов и примеров пока немного, мое любопытство заставило меня погрузиться в работу и изучить потенциал. В этом путешествии я решил создать простого математического помощника, который послужит доказательством концепции реализации вызовов функций в новом API Assistant в Node.js.</p>
<p>В этом примере мы сначала создадим простую викторину, чтобы протестировать вызов функций, а затем сможем продолжить разговор с помощником, чтобы задать больше вопросов, сохраняя при этом контекст разговора.</p>
<h2 id="реализация">Реализация<a aria-hidden="true" tabindex="-1" href="#реализация"><span class="icon icon-link"></span></a></h2>
<p>Для этого примера я использовал пример книги рецептов, предоставленный OpenAI, и стратегию командной строки из этого поста от Ральфа Эльфвинга, и немного подправил ее, чтобы сделать более интерактивной.</p>
<p>Нам понадобится всего несколько основных вещей:</p>
<h2 id="api-ключ-openai-среда-nodejs">API-ключ OpenAI Среда Node.js<a aria-hidden="true" tabindex="-1" href="#api-ключ-openai-среда-nodejs"><span class="icon icon-link"></span></a></h2>
<p>Для начала работы нам понадобятся пакеты <code>openai</code> и <code>dotenv</code>:</p>
<p><code>npm install openai dotenv</code>.</p>
<p>Объявите ваш ключ API как переменную окружения: в вашем .env</p>
<p><code>OPENAI_API_KEY=your-api-key</code></p>
<p>После этого мы можем приступить к работе с кодом:</p>
<p><code>// импортируем необходимые зависимости require('dotenv').config(); const OpenAI = require('openai'); const readline = require('readline').createInterface({ input: process.stdin, output: process.stdout, }); // Создаем соединение OpenAI const secretKey = process.env.OPENAI_API_KEY; const openai = new OpenAI({ apiKey: secretKey, });</code>.</p>
<p>Создадим метод и <code>readline</code> для ожидания пользовательского ввода</p>
<p><code>async function askRLineQuestion(question: string) { return new Promise&#x3C;string>((resolve, _reject) => { readline.question(question, (answer: string) => { resolve(`${answer}\n`); }); }); }</code></p>
<p>Теперь мы создадим функцию <code>main</code> для запуска нашей программы.</p>
<h2 id="начнем-с-создания-помощника">Начнем с создания помощника.<a aria-hidden="true" tabindex="-1" href="#начнем-с-создания-помощника"><span class="icon icon-link"></span></a></h2>
<p>Для этого помощника потребуются инструменты <code>code_interpreter</code> и <code>function</code>, и мы будем использовать модель <code>gpt-4-1106-preview</code>. Я экспериментировал с моделью <code>gpt-3.5-turbo-1106</code>, но, похоже, она работает не так хорошо, как модель <code>gpt-4-1106-preview</code>.</p>
<p>Я переделал вызов функции в функцию <code>quizJson</code>, которая возвращает JSON-объект с вопросами и ответами викторины, чтобы было легче читать.</p>
<p><code>const quizJson = { name: "display_quiz", description: "Отображает викторину для ученика и возвращает его ответ. В одном тесте может быть несколько вопросов.", parameters: { type: "object", properties: { title: { type: "string" }, questions: { type: "array", description: "Массив вопросов, каждый из которых имеет заголовок и потенциально возможные варианты ответов (при множественном выборе).", items: { type: "object", properties: { question_text: { type: "string" }, question_type: { type: "string", enum: ["MULTIPLE_CHOICE", "FREE_RESPONSE"], }, choices: { type: "array", items: { type: "string" } }, }, required: ["question_text"], }, }, }, }, required: ["title", "questions"], }, }; async function main() { try { const assistant = await openai.beta.assistants.create({ name: "Math Tutor", instructions: "Вы - персональный репетитор по математике. Отвечайте на вопросы кратко, в одном предложении или меньше.", tools: [ { { type: "code_interpreter" }, { type: "function", function: quizJson, }, ], // будет работать гораздо лучше с новой моделью model: "gpt-4-1106-preview", // model: "gpt-3.5-turbo-1106", }); // Записываем первое приветствие console.log("\nЗдравствуйте, я личный помощник Фернандо по математике. Начнем с небольшогоl quiz.\n", );</code></p>
<p>После создания ассистента мы создадим поток, который будет хранить состояние нашего разговора, чтобы нам не приходилось предоставлять контекст каждый раз, когда мы задаем вопрос. Помните, что модель не имеет состояния, поэтому нам нужно предоставлять контекст каждый раз, когда мы задаем вопрос.</p>
<p><code>const thread = await openai.beta.threads.create();</code></p>
<p>Чтобы приложение могло выполняться многократно, мы используем цикл <code>while</code>. Этот цикл будет оценивать вводимые пользователем данные после каждого вопроса, чтобы определить, намерен ли он продолжать или нет. У нас также будет переменная <code>isQuizAnswered</code> для отслеживания состояния викторины.</p>
<p><code>// метод main // создаем помощника и поток, как упоминалось выше let continueConversation = true; let isQuizAnswered = false; while (continueConversation) { // логика // после завершения вопроса-ответа проверяем, хочет ли пользователь продолжить const continueAsking = await askRLineQuestion( "Хотите ли вы продолжить разговор? (да/нет) ", ); continueConversation = continueAsking.toLowerCase() === "yes"; // Если состояние continueConversation является ложным, покажите сообщение о завершении разговора if (!continueConversation) { console.log("Ну что ж, надеюсь, вы чему-то научились!\n"); } }</code></p>
<p>Логика процесса “вопрос-ответ” будет выглядеть следующим образом:</p>
<p><code>while (continueConversation) { // сначала задаем вопрос и ждем ответа // начинаем с викторины, а затем продолжаем разговор const userQuestion = isQuizAnswered ? await askRLineQuestion("Ваш следующий вопрос к модели: \n") // это заставит модель построить викторину, используя предоставленную нами функцию : "Make a quiz with 2 questions: Один открытый, другой с множественным выбором" + "Затем дайте мне обратную связь для ответов."; // Передаем вопрос пользователя в существующий поток await openai.beta.threads.messages.create(thread.id, { role: "user", content: userQuestion, }); // Используем прогоны для ожидания ответа ассистента и последующего его получения // Создание прогона укажет ассистенту, что он должен начать просматривать сообщения в потоке и предпринять действия, вызвав инструменты или модель. const run = await openai.beta.threads.runs.create(thread.id, { assistant_id: assistant.id, }); // затем извлекаем фактический прогон let actualRun = await openai.beta.threads.runs.retrieve( // используем созданный ранее поток thread.id, run.id, );</code>.</p>
<p>Далее следует стратегия опроса для ожидания завершения обработки ответа моделью. Это немного хак, но на данный момент он работает. Мы будем ждать, пока модель закончит обработку ответа, а затем получим его.</p>
<p>Ожидаемый цикл выглядит следующим образом:</p>
<p>Предшествует викторине: Модель будет возвращать статус <code>queued</code>, затем статус <code>in_progress</code>, пока обрабатывает ответ После того как <code>tool_calls</code> будут добавлены для последующего использования, модель будет возвращать статус <code>requires_action</code>. Здесь мы фактически выполним функцию. Как только функция будет выполнена, мы передадим результаты работы инструмента в прогон, чтобы продолжить разговор. Наконец, модель вернет статус <code>completed</code>, и мы получим ответ. Если пользователь захочет продолжить разговор, мы повторим процесс, но на этот раз пропустим викторину и просто зададим вопрос пользователю.</p>
<p><code>while ( actualRun.status === "queued" || actualRun.status === "in_progress" || actualRun.status === "requires_action" ) { // requires_action означает, что помощник ждет добавления функций if (actualRun.status === "requires_action") { // дополнительный вызов одного инструмента const toolCall = actualRun.required_action?.submit_tool_outputs?.tool_calls[0]; const name = toolCall?.function.name; const args = JSON.parse(toolCall?.function?.arguments || "{}"); const questions = args.questions; const responses = await displayQuiz(name || "cool quiz", questions); // переключаем флаг, устанавливающий начальный тест isQuizAnswered = true; // для продолжения работы мы должны отправить выходы инструментов в запуск await openai.beta.threads.runs.submitToolOutputs( thread.id, run.id, { tool_outputs: [ { { tool_call_id: toolCall?.id, output: JSON.stringify(responses), }, ], }, ); } // продолжаем опрос до завершения выполнения await new Promise((resolve) => setTimeout(resolve, 2000)); actualRun = await openai.beta.threads.runs.retrieve(thread.id, run.id); }</code>.</p>
<p>К этому моменту мы должны получить ответ от модели, поэтому отобразим его пользователю, а затем спросим, хочет ли он продолжить разговор.</p>
<p><code>// после завершения выполнения выводим ответ console.log(actualRun.results[0].assistant_messages[0].content); // затем спрашиваем, хочет ли пользователь продолжить const continueAsking = await askRLineQuestion("Хотите ли вы продолжить разговор? (да/нет) ", ); continueConversation = continueAsking.toLowerCase() === "yes"; // Если состояние continueConversation является ложным, покажите завершающее сообщение if (!continueConversation) { console.log("Ну что ж, надеюсь, вы чему-то научились!\n"); } }</code></p>
<p>Наконец, мы добавим <code>displayQuiz</code>. функция. Эта функция примет название викторины и вопросы и отобразит их пользователю. Затем она будет ждать, пока пользователь ответит на вопросы, и вернет ответы.</p>
<p><code>// Получаем последнее сообщение ассистента из массива сообщений const messages = await openai.beta.threads.messages.list(thread.id); // Находим последнее сообщение для текущего запуска const lastMessageForRun = messages.data .filter( (message) => message.run_id === run.id &#x26;&#x26; message.role === "assistant", ) .pop(); // Если сообщение ассистента найдено, console.log() it if (lastMessageForRun) { // видимо, массив `content` неправильно набран // content возвращает an of objects do contain a text object const messageValue = lastMessageForRun.content[0] as { text: { value: string }; }; console.log(`${messageValue?.text?.value} \n`); }</code></p>
<p>Для поддержания разговора у нас есть возможность снова прочитать пользовательский ввод, что позволит отключить - при необходимости - флаг <code>continueConversation</code> или повторить процесс в разговорной манере.</p>
<p><code>// затем спрашиваем, хочет ли пользователь продолжить const continueAsking = await askRLineQuestion( "Хотите ли вы продолжить разговор? (да/нет) ", ); continueConversation = continueAsking.toLowerCase().includes("yes"); // Если состояние continueConversation является ложным, покажите завершающее сообщение if (!continueConversation) { console.log("Ну что ж, надеюсь, вы чему-то научились!\n"); } }</code></p>
<p>Не забудьте закрыть интерфейс <code>readline</code>.</p>
<p><code>readline.close(); } catch (error) { console.error(error); } }</code></p>
<h2 id="наконец-мы-вызовем-функцию-main-чтобы-запустить-программу">Наконец, мы вызовем функцию <code>main</code>, чтобы запустить программу.<a aria-hidden="true" tabindex="-1" href="#наконец-мы-вызовем-функцию-main-чтобы-запустить-программу"><span class="icon icon-link"></span></a></h2>
<p><code>// вызов функции main после ее объявления main();</code></p>
<p>А полная функция <code>main</code> будет выглядеть так:</p>
<p><code>async function main() { try { const assistant = await openai.beta.assistants.create({ name: "Math Tutor", instructions: "Вы - персональный репетитор по математике. Отвечайте на вопросы кратко, не более одного предложения.", инструменты: [ { { type: "code_interpreter" }, { type: "function", function: quizJson, }, ], // будет работать гораздо лучше с новой моделью model: "gpt-4-1106-preview", // model: "gpt-3.5-turbo-1106", }); // Записываем первое приветствие console.log("\nЗдравствуйте, я личный помощник Фернандо по математике. Начнем с небольшой викторины.\n", ); // Создаем поток const thread = await openai.beta.threads.create(); // Используем continueConversation как состояние для продолжения задавания вопросов let continueConversation = true; while (continueConversation) { const userQuestion = isQuizAnswered ? await askRLineQuestion("Ваш следующий вопрос к модели: \n") // Это заставит модель построить викторину с помощью нашей функции: "Сделать викторину с 2 вопросами: Один открытый, другой с множественным выбором" + "Затем дайте мне обратную связь для ответов."; // Передаем вопрос пользователя в существующий поток await openai.beta.threads.messages.create(thread.id, { role: "user", content: userQuestion, }); // Используем прогоны для ожидания ответа помощника и последующего его получения const run = await openai.beta.threads.runs.create(thread.id, { assistant_id: assistant.id, }); let actualRun = await openai.beta.threads.runs.retrieve( thread.id, run.id, ); // Механизм опроса для проверки завершения actualRun while ( actualRun.status === "queued" || actualRun.status === "in_progress" || actualRun.status === "requires_action" ) { // requires_action означает, что помощник ждет добавления функций if (actualRun.status === "requires_action") { // дополнительный вызов одного инструмента const toolCall = actualRun.required_action?.submit_tool_outputs?.tool_calls[0]; const name = toolCall?.function.name; const args = JSON.parse(toolCall?.function?.arguments || "{}"); const questions = args.questions; const responses = await displayQuiz(name || "cool quiz", questions); // переключаем флаг, устанавливающий начальный тест isQuizAnswered = true; // для продолжения работы мы должны отправить выходы инструментов в запуск await openai.beta.threads.runs.submitToolOutputs( thread.id, run.id, { tool_outputs: [ { { tool_call_id: toolCall?.id, output: JSON.stringify(responses), }, ], }, ); } // продолжаем опрос до завершения выполнения await new Promise((resolve) => setTimeout(resolve, 2000)); actualRun = await openai.beta.threads.runs.retrieve(thread.id, run.id); }  // Получаем последнее сообщение ассистента из массива сообщений const messages = await openai.beta.threads.messages.list(thread.id); // Находим последнее сообщение для текущего запуска const lastMessageForRun = messages.data .filter( (message) => message.run_id === run.id &#x26;&#x26; message.role === "assistant", ) .pop(); // Если сообщение ассистента найдено, console.log() it if (lastMessageForRun) { // видимо, массив </code>content<code> неправильно набран // content возвращает an of objects do contain a text object const messageValue = lastMessageForRun.content[0] as { text: { value: string }; }; console.log(</code>${messageValue?text?value} \n<code>); }  // Затем спрашиваем, хочет ли пользователь задать еще один вопрос, и обновляем состояние continueConversation const continueAsking = await askRLineQuestion("Хотите ли вы продолжить разговор? (да/нет) ", ); continueConversation = continueAsking.toLowerCase().includes("yes"); // Если состояние continueConversation falsy, покажите сообщение о завершении разговора if (!continueConversation) { console.log("Ну что ж, надеюсь, вы чему-то научились!\n"); } }  // закрываем readline readline.close(); } catch (error) { console.error(error); } }</code></p>
<p>Если вы создали новый проект node с помощью <code>npm init</code> - рекомендуется - вы можете добавить скрипт для запуска вашего проекта следующим образом</p>
<p><code>{ "scripts": { "start": "ts-node yourFileName.ts" } }</code></p>
<p>Теперь мы можем запустить нашу программу с помощью <code>npm start</code> и получить следующий результат:</p>
<p><code>Здравствуйте, я личный помощник Фернандо по математике. Начнем с небольшой викторины. > Викторина: display_quiz Вопрос: Что такое производная от 3x^2? f'(x) = 6x Вопрос: Что такое интеграл от x dx? Варианты: 0,5x^2 + C,x^2 + C,2x + C,Ни один из них 0,5x^2 + C Ваши ответы из викторины: ["f'(x) = 6x\n", '0.5x^2 + C\n' ] Отличная работа над тестом! Ваш ответ на первый вопрос, производная ( 3x^2 ), верен; это ( 6x ). Во втором вопросе вы правильно выбрали ( 0.5x^2 + C ) как интеграл от ( x ) относительно ( x ). Отличная работа! Продолжайте в том же духе! Хотите ли вы продолжить разговор? (да/нет) да Следующий вопрос вы задаете модели: Почему вы задали вопрос о производных и интегралах. Прошло много лет с тех пор, как я занимался этим. Приношу свои извинения за выбор этих математических тем. Обычно в математическом контексте используются вопросы по калькуляции, но я понимаю, что они могут быть не у всех в памяти. Если у вас есть другие области интересов или конкретные темы, которые вы хотели бы рассмотреть или узнать, пожалуйста, дайте мне знать, и я смогу адаптировать содержание соответствующим образом. Хотите ли вы продолжить разговор? (да/нет) нет Хорошо, надеюсь, вы чему-то научились!</code></p>
<p>Вот и все! Мы создали простой математический помощник, который может отвечать на вопросы и поддерживать беседу. Это всего лишь пример концепции, но он демонстрирует потенциал нового API Assistant. Я уверен, что в ближайшем будущем мы увидим больше примеров и вариантов использования.</p>
<p>Если вы хотите посмотреть полный код, вы можете найти его в этом репо</p> <div class="share article__share" data-astro-cid-g7nhfqu5> <h3 class="share__title" data-astro-cid-g7nhfqu5>Поделиться:</h3> <ul class="share__list" data-astro-cid-g7nhfqu5> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://vk.com/share.php?url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Vk
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="facebook share button" href="https://facebook.com/sharer/sharer.php?u=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Fb
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="twitter share button" href="https://twitter.com/share?title=Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций&#38;url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
X
</a> </li><li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="linkedin share button" href="https://www.linkedin.com/shareArticle?mini=true&#38;url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi&#38;title=Создайте чатбота с помощью нового API OpenAI Assistant и вызова функций&#38;summary=Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога O&#38;source=https://igorlov.ru/" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Linkd
</a> </li> <li class="share__item" data-astro-cid-g7nhfqu5> <a class="share__link" aria-label="pinterest share button" href="https://pinterest.com/pin/create/button/?url=https://igorlov.ru/blog/sozdaite-chatbota-s-pomoschiu-novoho-api-openai-assistant-y-v-zova-funktsyi&#38;media=&#38;description=Прошла всего неделя с конференции OpenAI Dev Conf 2023, и на ней было сделано неожиданное открытие: API помощника. Представленный в последнем сообщении блога O" target="_blank" rel="noreferrer noopener" data-astro-cid-g7nhfqu5>
Pint
</a> </li> </ul>  </div> <nav class="circular-pagination" aria-label="Circular Pagination" data-astro-cid-ihkjvfsn> <a href="/blog/postroite-konveier-ci_cd-dlia-prylozhenyi-flask-s-pomoschiu-github-actions" class="circular-pagination__link circular-pagination__link--prev" data-astro-cid-ihkjvfsn> Постройте конвейер CI/CD для приложений Flask с помощью GitHub Actions </a> <a href="/blog/uvelychenye-brauzera-css-obrabotchyky-sob-tyi-y-dostupnost" class="circular-pagination__link circular-pagination__link--next" data-astro-cid-ihkjvfsn> Увеличение браузера, CSS, обработчики событий и доступность </a> </nav>  </div> </article> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><astro-island uid="Z1T5Wnr" prefix="r0" component-url="/_astro/YandexRelatedAds.svLg6TOn.js" component-export="default" renderer-url="/_astro/client.D9Vng9vH.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;YandexRelatedAds&quot;,&quot;value&quot;:true}" await-children=""><div id="yandex_rtb_C-A-2592503-2"></div><!--astro:end--></astro-island> <astro-island uid="Z2a8j9B" component-url="/_astro/CommentBlock.BwogX8bT.js" component-export="default" renderer-url="/_astro/client.DtEXyQF-.js" props="{&quot;data-astro-cid-axzg2cw6&quot;:[0,true]}" ssr="" client="only" opts="{&quot;name&quot;:&quot;CommentBlock&quot;,&quot;value&quot;:true}"></astro-island>  </div> <!-- <div class="blocks__container container">
			<CtaBlock id="cta" class=""
			/>
		</div> --> </div>    </main> <footer class="footer" data-astro-cid-dwelrhxs> <div class="footer__container container" data-astro-cid-dwelrhxs> <a href="/" class="logo font-extrabold lowercase transition-colors fluid:text-lg footer__logo dark:hover:text-light text-dark  dark:text-gray" aria-label="logo" data-astro-cid-ijoll5s5>ФCВР</a>  <small class="footer__copyright" data-astro-cid-dwelrhxs>все права защищены. © 2024</small> </div> </footer>  </body></html>